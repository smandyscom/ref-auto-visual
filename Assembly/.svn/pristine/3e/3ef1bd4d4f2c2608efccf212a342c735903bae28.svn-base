Imports MathNet.Numerics.LinearAlgebra
Imports MathNet.Spatial.Euclidean
Imports AutoNumeric
Imports AutoNumeric.fittingMethods.coeffsDefinition
Imports FA.dataKeysDefine


Public Enum dataKeysDefine As Integer
    X = 0
    Y = 1
    VOLTAGE_LEFT = 2
    VOLTAGE_RIGHT = 2

End Enum


''' <summary>
''' The bonded material data , going to report
''' </summary>
''' <remarks></remarks>
Public Class materialData

    'image
    'intensity

    'raw dry/wet

    'peak value
    'width

    'eproxy diameter/position

    'dry/wet
    Friend scanningDatas As Dictionary(Of framesDefinition, scanningData) =
         New Dictionary(Of framesDefinition, scanningData)

    Property IsEnagedToBond As Boolean = True

End Class


''' <summary>
''' Given raw data 
''' Output:
''' 1. parabolic profiles
''' 2. peak values ( left/right)
''' </summary>
''' <remarks></remarks>
Public Class scanningData

    ''' <summary>
    ''' In mm , the norminal distance between right-left
    ''' </summary>
    ''' <remarks></remarks>
    Shared WriteOnly Property NominalChannelDistance As Double
        Set(value As Double)
            __nominalChannelDistance = value
            __nominalRight = CreateVector.Dense(Of Double)({__nominalChannelDistance,
                                                                              0})
            __nominalMiddle = __nominalMiddle / 2
        End Set
    End Property

    Shared __nominalRight As Vector(Of Double) = CreateVector.Dense(Of Double)({__nominalChannelDistance,
                                                                              0})
    Shared __nominalMiddle As Vector(Of Double) = __nominalRight / 2
    Shared __nominalChannelDistance As Double = 1

    Dim __rightCoordinate As Vector(Of Double) = Nothing
    Dim __leftCoordinate As Vector(Of Double) = Nothing

    ''' <summary>
    ''' According to scanned data
    ''' </summary>
    ''' <value></value>
    ''' <returns></returns>
    ''' <remarks></remarks>
    ReadOnly Property RevicedCoordinate As Matrix(Of Double)
        Get
            Return __revicedCoordinate
        End Get
    End Property
    Dim __revicedCoordinate As Matrix(Of Double) = CreateMatrix.DenseIdentity(Of Double)(4)

    Dim channelDatas As Dictionary(Of dataKeysDefine, channelData) =
        New Dictionary(Of dataKeysDefine, channelData)


    Sub New(leftRawData As List(Of Vector(Of Double)),
            rightRawData As List(Of Vector(Of Double)))

        channelDatas(VOLTAGE_LEFT) = New channelData(leftRawData)
        channelDatas(VOLTAGE_RIGHT) = New channelData(rightRawData)


        __rightCoordinate = channelDatas(VOLTAGE_RIGHT).PeakCoordinate + __nominalRight
        __leftCoordinate = channelDatas(VOLTAGE_LEFT).PeakCoordinate

        '(right-left).nomalize  = X axis (revised)
        Dim zAxis As Vector(Of Double) = CreateVector.Dense(Of Double)({0,
                                                                        0,
                                                                        1})
        Dim xAxis As Vector(Of Double) = (__rightCoordinate - __leftCoordinate).Normalize(2)
        Dim yAxis As Vector(Of Double) = Vector3D.OfVector(zAxis).CrossProduct(Vector3D.OfVector(xAxis)).ToVector

        Dim offset As Vector(Of Double) = (channelDatas(VOLTAGE_LEFT).PeakCoordinate + channelDatas(VOLTAGE_RIGHT).PeakCoordinate) / 2


        __revicedCoordinate.SetColumn(axisEntityEnum.X, xAxis)
        __revicedCoordinate.SetColumn(axisEntityEnum.Y, yAxis)
        __revicedCoordinate.SetColumn(axisEntityEnum.Z, zAxis)
        __revicedCoordinate.SetColumn(__revicedCoordinate.ColumnCount - 1, offset)

    End Sub

End Class


Public Class channelData

    Property Profile As Vector(Of Double)
        Get
            Return __profile
        End Get
        Set(value As Vector(Of Double))
            __profile = value
            'according to parabolic profile
            __peakCoordinate = CreateVector.Dense(Of Double)({-__profile(B) / (2 * __profile(A)),
                                                            -__profile(E) / (2 * __profile(D))})
        End Set
    End Property
    ReadOnly Property PeakCoordinate As Vector(Of Double)
        Get
            Return __peakCoordinate
        End Get
    End Property

    ReadOnly Property BeamWidthX As Double
        Get
            Return solveX.L1Norm
        End Get
    End Property
    ReadOnly Property BeamWidthY As Double
        Get
            Return solveY.L1Norm
        End Get
    End Property

    ''' <summary>
    ''' 0: X
    ''' 1: Y
    ''' 2: VOLTAGE
    ''' </summary>
    ''' <remarks></remarks>
    Dim rawData As List(Of Vector(Of Double)) = New List(Of Vector(Of Double))
    Dim rangeX As Vector(Of Double) = Nothing
    Dim rangeY As Vector(Of Double) = Nothing

    Dim amptitude As Double = 0.707 '3db
    Dim solveX As Vector(Of Double) = Nothing
    Dim solveY As Vector(Of Double) = Nothing

    ''' <summary>
    ''' 6x1 vector
    ''' ax^2 + bx + cy^2 + dy + ez + f = 0
    ''' </summary>
    ''' <remarks></remarks>
    Dim __profile As Vector(Of Double) = Nothing
    Dim peakValueDetected As Double = Nothing
    Dim peakValueFitted As Double = Nothing

    Dim __peakCoordinate As Vector(Of Double) = Nothing

    Dim __isProfileAccepted As Boolean = False

    Sub New(__rawData As List(Of Vector(Of Double)))

        '--------------
        '
        '--------------
        rangeX = CreateVector.Dense(Of Double)({rawData.Min(Function(data As Vector(Of Double)) data.First),
                                                rawData.Max(Function(data As Vector(Of Double)) data.First)})
        rangeY = CreateVector.Dense(Of Double)({rawData.Min(Function(data As Vector(Of Double)) data.Last),
                                                rawData.Max(Function(data As Vector(Of Double)) data.Last)})


        __profile = fittingMethods.data3DFitting(rawData, fittingMethods.fitting3DMethodsEnum.DOUBLE_PARABOLA)

        '--------------------
        '   Find out real peak
        '--------------------
        peakValueDetected =
            rawData.Max(Function(data As Vector(Of Double)) data.Last)
        peakValueFitted = fittingMethods.data3D(__peakCoordinate.First,
                                                __peakCoordinate.Last,
                                                __profile)

        'verify
        ' the peak value is happened within searching range
        'solve corresponding X/Y , check if X/Y is in the scanning range
        __isProfileAccepted = __peakCoordinate.First >= rangeX.First And
            __peakCoordinate.First <= rangeX.Last And
            __peakCoordinate.Last >= rangeY.First And
            __peakCoordinate.Last <= rangeY.Last


        'calculate beam width
        'solve x1,x2,y1,y2 on -3db peak value
        Dim __const As Double = __profile(C) * __peakCoordinate(Y) ^ 2 +
            __profile(D) * __peakCoordinate(Y) +
            __profile(E) * peakValueFitted * amptitude +
            __profile(F)

        solveX = fittingMethods.parabolicSolver(0,
                                                CreateVector.Dense(Of Double)({__profile(A),
                                                                               __profile(B),
                                                                               __const}))
        __const = __profile(A) * __peakCoordinate(X) ^ 2 +
            __profile(B) * __peakCoordinate(X) +
            __profile(E) * peakValueFitted * amptitude +
            __profile(F)

        solveY = fittingMethods.parabolicSolver(0,
                                                CreateVector.Dense(Of Double)({__profile(C),
                                                                               __profile(D),
                                                                               __const}))



    End Sub

End Class
Imports MathNet.Numerics.LinearAlgebra
Imports System.Xml.Serialization
Imports System.IO

''' <summary>
''' T_from(right)_to(left)
''' </summary>
''' <remarks></remarks>
Public Enum transformationsEnum
    T_C1_R
    T_C2_R
    T_LPD_S
End Enum

Enum rItemsEnum
    ValueOne
    ValueTwo
    CHOCKER
End Enum

''' <summary>
''' Depict machine frame structure
''' </summary>
''' <remarks></remarks>
Public Class frames

    ''' <summary>
    ''' Used to store frames
    ''' Update/Query
    ''' </summary>
    ''' <remarks></remarks>
    Public Shared frameDictionary As Dictionary(Of transformationsEnum, Matrix(Of Double)) = New Dictionary(Of transformationsEnum, Matrix(Of Double))

    ''' <summary>
    ''' 
    ''' </summary>
    ''' <param name="_From"></param>
    ''' <param name="_To"></param>
    ''' <param name="ax"></param>
    ''' <param name="ay"></param>
    ''' <param name="podVector"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Shared Function relation(_From As transformationsEnum,
                    _To As transformationsEnum,
                    Optional ax As Double = 0,
                    Optional ay As Double = 0,
                    Optional podVector As Object = Nothing) As Matrix(Of Double)

    End Function

    ''' <summary>
    ''' Given item , solve the nominal axis value
    ''' </summary>
    ''' <param name="rItem"></param>
    ''' <param name="yItem"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Shared Function solveXY(rItem, yItem) As Object

    End Function

End Class




Public Class CalibrationChain

    Public tolerance As Double = 0.001

    Private __nominal As MechanismNominal = New MechanismNominal
    Private __serializer As XmlSerializer = New XmlSerializer(GetType(MechanismNominal))

    Private stack_deltaPC1 As Matrix(Of Double) = Nothing
    Private stack_ErrorCoefficient As Matrix(Of Double) = Nothing

    ' unknown
    Private Error_C(3) As Matrix(Of Double)         ' (6x1)
    Private T_Ci_Cr(3) As Matrix(Of Double)         ' (4x4)

    ' known
    Private __T_R_C(3) As Matrix(Of Double)         ' (4x4)
    Private __T_S0_R As Matrix(Of Double)           ' (4x4)
    Private __T_S_S0 As Matrix(Of Double)           ' (4x4)
    Private __P_B As Matrix(Of Double)              ' (4x1)


    Public Sub initialize()
        Error_C(1) = Matrix(Of Double).Build.Dense(6, 1, {0, 0, 0, 0, 0, 0})
        Error_C(2) = Matrix(Of Double).Build.Dense(6, 1, {0, 0, 0, 0, 0, 0})
        Error_C(3) = Matrix(Of Double).Build.Dense(6, 1, {0, 0, 0, 0, 0, 0})
        T_Ci_Cr(1) = Matrix(Of Double).Build.DenseDiagonal(4, 1.0)
        T_Ci_Cr(2) = Matrix(Of Double).Build.DenseDiagonal(4, 1.0)
        T_Ci_Cr(3) = Matrix(Of Double).Build.DenseDiagonal(4, 1.0)

        Try
            __T_R_C(1) = MatrixOperation.LoadMatrix("Data\T_R_C1.txt")
            __T_R_C(2) = MatrixOperation.LoadMatrix("Data\T_R_C2.txt")
            __T_R_C(3) = MatrixOperation.LoadMatrix("Data\T_R_C3.txt")
            __T_S0_R = MatrixOperation.LoadMatrix("Data\T_S0_R.txt")
            __T_S_S0 = MatrixOperation.LoadMatrix("Data\T_S_S0.txt")
            __P_B = MatrixOperation.LoadMatrix("Data\P_B.txt")
        Catch ex As Exception
            MessageBox.Show(ex.Message)
        End Try

    End Sub

    Public Sub SaveNominal()
        Using sw As StreamWriter = New StreamWriter("Data\MechanismNominal.xml")
            __serializer.Serialize(sw, __nominal)
        End Using
    End Sub

    Public Sub LoadNominal()
        Using sr As StreamReader = New StreamReader("Data\MechanismNominal.xml")
            __nominal = __serializer.Deserialize(sr)
        End Using
    End Sub

    Public Function T_S_S0(mat_Pod As Matrix(Of Double)) As Matrix(Of Double)
        Return MatrixOperation.smarpod_fixed_forward(mat_Pod)
    End Function

    Public Function T_S0_R(Ax As Double) As Matrix(Of Double)
        __T_S0_R(0, 3) = __T_S0_R(0, 3) + Ax
        Return __T_S0_R
    End Function

    ''' <summary>
    ''' Ideal P_C (4x1 Matrix)
    ''' </summary>
    ''' <param name="camera_i"></param>
    ''' <param name="Ax"></param>
    ''' <param name="mat_Pod"> (6x1) matrix of pod posture</param>
    ''' <param name="P_B"> (4x1) matrix of point</param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Public Function P_Ci_ideal(camera_i As Integer, Ax As Double, mat_Pod As Matrix(Of Double), P_B As Matrix(Of Double)) As Matrix(Of Double)
        Return T_Ci_Cr(camera_i) * __T_R_C(camera_i) * T_S0_R(Ax) * T_S_S0(mat_Pod) * P_B
    End Function

    ''' <summary>
    ''' Difference between P_C_ideal and P_C_real (2x1 Matrix)
    ''' </summary>
    ''' <param name="mat_ideal"> 2x1 matrix</param>
    ''' <param name="mat_real"> 2x1 matrix</param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Public Function P_C_Error(mat_ideal As Matrix(Of Double), mat_real As Matrix(Of Double)) As Matrix(Of Double)
        Return mat_ideal - mat_real
    End Function

    ''' <summary>
    ''' Error Coefficient Matrix of C
    ''' </summary>
    ''' <param name="Ax"></param>
    ''' <param name="mat_Pod">(6x1) matrix of pod posture</param>
    ''' <returns>(2x6) error coefficient matrix</returns>
    ''' <remarks></remarks>
    Public Function ErrorCoefficient_C(camera_i As Integer, Ax As Double, mat_Pod As Matrix(Of Double)) As Matrix(Of Double)

        Dim C1x As Double = __nominal.C1x
        Dim C1y As Double = __nominal.C1y
        Dim C1z As Double = __nominal.C1z
        Dim C2x As Double = __nominal.C2x
        Dim C2y As Double = __nominal.C2y
        Dim C2z As Double = __nominal.C2z
        Dim C3x As Double = __nominal.C3x
        Dim C3y As Double = __nominal.C3y
        Dim C3z As Double = __nominal.C3z
        Dim Px As Double = __P_B(0, 0)
        Dim Py As Double = __P_B(1, 0)
        Dim Pz As Double = __P_B(2, 0)
        Dim S0X As Double = __nominal.S0x
        Dim S0Y As Double = __nominal.S0y
        Dim S0Z As Double = __nominal.S0z
        Dim Sx As Double = mat_Pod(0, 0)
        Dim Sy As Double = mat_Pod(1, 0)
        Dim Sz As Double = mat_Pod(2, 0)

        Select Case camera_i
            Case 1
                Return Matrix(Of Double).Build.DenseOfArray({{-1, 0, 0, 0, (-Ax + C1x + Px + Sx), (-C1z - Pz + S0Z - Sz)},
                                                     {0, -1, 0, (Ax - C1x - Pz - Sx), 0, (-C1y + Py + S0Y + Sy)}})
                ' C1 error analysis (x, y, z, rx, ry, rz)
                '   |   -1      0       0           0         (-Ax+C1x+Px+Sx)     (-C1z-Pz+S0Z-Sz)  |
                '   |    0     -1       0    (Ax-C1x-Pz-Sx)          0            (-C1y+Py+S0Y+Sy)  |
            Case 2
                Return Matrix(Of Double).Build.DenseOfArray({{-1, 0, 0, 0, (C2y - Py - S0Y - Sy), (C2z + Pz - S0Z + Sz)},
                                                     {0, -1, 0, (-C2y + Py + S0Y + Sy), 0, (-Ax + C2x + Px + Sx)}})
                ' C2 error analysis
                '   |   -1      0       0           0         (C2y-Py-S0Y-Sy)      (C2z+Pz-S0Z+Sz)  |
                '   |    0     -1       0   (-C2y+Py+S0Y+Sy)         0             (-Ax+C2x+Px+Sx)  |
            Case 3
                Return Matrix(Of Double).Build.DenseOfArray({{-1, 0, 0, 0, (C3z + Pz - S0Z + Sz), (-C3y + Py + S0Y + Sy)},
                                                     {0, -1, 0, (-C3z - Pz + S0Z - Sz), 0, (-Ax + C3x + Px + Sx)}})
                ' C3 error analysis
                '   |   -1      0       0           0          (C3z+Pz-S0Z+Sz)     (-C3y+Py+S0Y+Sy) |
                '   |    0     -1       0    (-C3z-Pz+S0Z-Sz)        0              (-Ax+C3x+Px+Sx) |
            Case Else
                Return Nothing
        End Select
    End Function

    ''' <summary>
    ''' T_ideal_real
    ''' </summary>
    ''' <param name="mat_error"> (6x1) matrix of error between ideal and real</param>
    ''' <returns> (4x4) error transformation matrix </returns>
    ''' <remarks></remarks>
    Public Function T_ideal_real(mat_error As Matrix(Of Double)) As Matrix(Of Double)
        Dim sx As Double = mat_error(0, 0)
        Dim sy As Double = mat_error(1, 0)
        Dim sz As Double = mat_error(2, 0)
        Dim ex As Double = mat_error(3, 0)
        Dim ey As Double = mat_error(4, 0)
        Dim ez As Double = mat_error(5, 0)
        Return Matrix(Of Double).Build.DenseOfArray({{1, -ez, ey, sx}, {ez, 1, -ex, sy}, {-ey, ex, 1, sz}, {0, 0, 0, 0}})
        ' T_ideal_real
        '   |   1       -ezy0   eyy0    sxy0    |
        '   |   ezy0    1       -exy0   syy0    |
        '   |   -eyy0   exy0    1       szy0    |
        '   |   0       0       0       1       |
    End Function

    ''' <summary>
    ''' iterate Error transformation matrix
    ''' </summary>
    ''' <param name="list_PodPosture"> n postures of smarpod </param>
    ''' <param name="list_PC_real"> n points measured by camera </param>
    ''' <param name="Ax"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Public Function IterateErrorTransMatrix(camera_i As Integer, list_PodPosture As List(Of Matrix(Of Double)), list_PC_real As List(Of Matrix(Of Double)), Ax As Double) As Integer
        Dim newError_C As Matrix(Of Double)
        Dim diff As Double = 1.0

        While (diff > tolerance)

            For i = 0 To list_PodPosture.Count
                stackErrorMatrix(camera_i, list_PodPosture(i), Ax, list_PC_real(i))
            Next

            newError_C = MatrixOperation.PseudoInverse(stack_ErrorCoefficient) * stack_deltaPC1
            T_Ci_Cr(camera_i) = T_ideal_real(Error_C(camera_i))

            diff = Error_C(camera_i).FrobeniusNorm() - newError_C.FrobeniusNorm()

            Error_C(camera_i) = newError_C
        End While

        Return 0
    End Function

    Public Sub stackErrorMatrix(camera_i As Integer, mat_Pod As Matrix(Of Double), Ax As Double, P_C_real As Matrix(Of Double))
        ' delta_P_C = CoefficientMatrix * ErrorMatrix

        If stack_deltaPC1 Is Nothing Then
            stack_deltaPC1 = Matrix(Of Double).Build.DenseOfMatrix(P_C_Error(P_Ci_ideal(1, Ax, mat_Pod, __P_B).SubMatrix(0, 2, 0, 1), P_C_real))
        Else
            stack_deltaPC1.Stack(P_C_Error(P_Ci_ideal(1, Ax, mat_Pod, __P_B).SubMatrix(0, 2, 0, 1), P_C_real))
        End If

        If stack_ErrorCoefficient Is Nothing Then
            stack_ErrorCoefficient = ErrorCoefficient_C(camera_i, Ax, mat_Pod)
        Else
            stack_ErrorCoefficient.Stack(ErrorCoefficient_C(camera_i, Ax, mat_Pod))
        End If

    End Sub

End Class

<Serializable>
Public Class MechanismNominal
    Property C1x As Double
    Property C1y As Double
    Property C1z As Double
    Property C2x As Double
    Property C2y As Double
    Property C2z As Double
    Property C3x As Double
    Property C3y As Double
    Property C3z As Double
    Property C4x As Double
    Property C4y As Double
    Property C4z As Double
    Property S0x As Double
    Property S0y As Double
    Property S0z As Double
    Property Y0x As Double
    Property Y0y As Double
    Property Y0z As Double
    Property Lx As Double
    Property Ly As Double
    Property Lz As Double
End Class
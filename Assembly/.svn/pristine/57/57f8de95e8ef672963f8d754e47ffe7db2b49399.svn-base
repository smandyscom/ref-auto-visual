Imports MathNet.Numerics.LinearAlgebra
Imports System.Xml
Imports System.Xml.Serialization
Imports System.IO
Imports MathNet.Numerics.Data.Text


Public Module MatrixOperation

    Public Sub test()
        Dim mat_A As Matrix(Of Double)
        Dim mat_B As Matrix(Of Double)
        Dim mat_C As Matrix(Of Double)
        Dim vec_A1 As Vector(Of Double)
        Dim vec_A2 As Vector(Of Double)
        Dim vec_A3 As Vector(Of Double)

        Dim array_Temp As Double(,) = {{1.0, 2.0}, {3.0, 4.0}}
        Dim mat1 As Matrix(Of Double)
        mat1 = CreateMatrix.DenseOfArray(Of Double)(array_Temp)

        '
        vec_A1 = CreateVector.Random(Of Double)(3)
        vec_A2 = CreateVector.Random(Of Double)(3)
        vec_A3 = CreateVector.Random(Of Double)(3)

        '       | Ve_A1(0) Ve_A2(0) Ve_A3(0) |
        ' A =   | Ve_A1(1) Ve_A2(1) Ve_A3(1) |
        '       | Ve_A1(2) Ve_A2(2) Ve_A3(2) |
        mat_A = CreateMatrix.DenseOfColumnVectors(Of Double)(vec_A1, vec_A2, vec_A3)

        '       | Ve_A1(0) Ve_A1(1) Ve_A1(2) |
        ' B =   | Ve_A2(0) Ve_A2(1) Ve_A2(2) |
        '       | Ve_A3(0) Ve_A3(1) Ve_A3(2) |
        mat_B = CreateMatrix.DenseOfRowVectors(Of Double)(vec_A1, vec_A2, vec_A3)

        '       | 2.0  2.0  2.0 |
        ' C =   | 2.0  2.0  2.0 |
        '       | 2.0  2.0  2.0 |
        mat_C = CreateMatrix.Dense(Of Double)(3, 3, 2.0)

        ' B = A + C
        mat_B = mat_A.Add(mat_C)

        '       | 0  3  6 |
        ' D =   | 1  4  7 |
        '       | 2  5  8 |
        Dim mat_D As Matrix(Of Double) = CreateMatrix.Dense(Of Double)(3, 3, {0, 1, 2, 3, 4, 5, 6, 7, 8})
        mat_D = Matrix(Of Double).Build.Dense(3, 3, {0, 1, 2, 3, 4, 5, 6, 7, 8})     ' the same

        '                   |  0   3   6 |
        ' E =|    D   | =   |  1   4   7 |
        '    | newRow |     |  2   5   8 |
        '                   | 10  20  30 |
        Dim newRow As Matrix(Of Double) = Matrix(Of Double).Build.Dense(1, 3, {10, 20, 30})
        Dim mat_E As Matrix(Of Double) = mat_D.Stack(newRow)

        '                        |  0   3   6  10 |
        ' F =| D   newCol |  =   |  1   4   7  20 |
        '                        |  2   5   8  30 |
        Dim newCol As Matrix(Of Double) = Matrix(Of Double).Build.Dense(3, 1, {10, 20, 30})
        Dim mat_F As Matrix(Of Double) = mat_D.Append(newCol)

        '       |  0   1   2 |
        ' FT =  |  3   4   5 |
        '       |  6   7   8 |
        '       | 10  20  30 |
        Dim mat_F_T As Matrix(Of Double) = mat_F.Transpose()

        '                 |  5   0   0 |
        ' mat_Diagonal =  |  0   5   0 |
        '                 |  0   0   5 |                
        Dim mat_Diagonal As Matrix(Of Double) = Matrix(Of Double).Build.Diagonal(3, 3, 5.0)
        Dim mat_Inv As Matrix(Of Double) = mat_Diagonal.Inverse()

        Dim mat_G As Matrix(Of Double) = Matrix(Of Double).Build.Dense(3, 3, {1, 0, 0, 0, 2, 0, 0, 0, 5})
        Dim mat_G_inv As Matrix(Of Double) = mat_G.Inverse()

        ' 
        Dim mat_F_pseudoInv As Matrix(Of Double) = PseudoInverse(mat_F)

        ' H = D x F
        'Dim mat_H As Matrix(Of Double) = mat_D.Multiply(mat_F)
        Dim mat_H As Matrix(Of Double) = mat_D * mat_F

        Dim mat_I As Matrix(Of Double) = RotateTransformation(Math.PI / 2, 0, 0)

        Dim mat_J As Matrix(Of Double) = mat_I * TranslateTransformation(0, 50, 0)

        Dim ttt As CalibrationChain = New CalibrationChain
        ttt.initialize()
    End Sub


    Public Function PseudoInverse(matrice As Matrix(Of Double)) As Matrix(Of Double)
        ' Reference: https://github.com/mathnet/mathnet-numerics/issues/432

        Dim svd As Factorization.Svd(Of Double) = matrice.Svd(True)
        Dim mat_W As Matrix(Of Double) = svd.W
        Dim vec_s As Vector(Of Double) = svd.S
        Dim torlerance As Double = Math.Max(matrice.RowCount, matrice.ColumnCount) * matrice.L2Norm * MathNet.Numerics.Precision.DoublePrecision

        For Each si In vec_s
            If si < torlerance Then
                si = 0
            Else
                si = 1 / si
            End If
        Next

        mat_W.SetDiagonal(vec_s)

        Return (svd.U * mat_W * svd.VT).Transpose()
    End Function

    '               |  1     0      0     0  |
    ' T_rotateX =   |  0  cos(a) -sin(a)  0  |
    '               |  0  sin(a)  cos(a)  0  |
    '               |  0     0      0     1  |

    '               |  cos(b)  0  sin(b)  0  |
    ' T_rotateY =   |    0     1    0     0  |
    '               | -sin(b)  0  cos(b)  0  |
    '               |    0     0    0     1  |

    '               |  cos(c) -sin(c)  0  0  |
    ' T_rotateZ =   |  sin(c)  cos(c)  0  0  |
    '               |    0       0     1  0  |
    '               |    0       0     0  1  |
    Public Function RotateTransformation(theta_x As Double, theta_y As Double, theta_z As Double) As Matrix(Of Double)
        Dim mat_rotateX As Matrix(Of Double) = Matrix(Of Double).Build.Dense(4, 4, {1, 0, 0, 0, 0, Math.Cos(theta_x), Math.Sin(theta_x), 0, 0, -Math.Sin(theta_x), Math.Cos(theta_x), 0, 0, 0, 0, 1})
        Dim mat_rotateY As Matrix(Of Double) = Matrix(Of Double).Build.Dense(4, 4, {Math.Cos(theta_y), 0, -Math.Sin(theta_y), 0, 0, 1, 0, 0, Math.Sin(theta_y), 0, Math.Cos(theta_y), 0, 0, 0, 0, 1})
        Dim mat_rotateZ As Matrix(Of Double) = Matrix(Of Double).Build.Dense(4, 4, {Math.Cos(theta_z), Math.Sin(theta_z), 0, 0, -Math.Sin(theta_z), Math.Cos(theta_z), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1})

        Return mat_rotateX * mat_rotateY * mat_rotateZ
    End Function

    '                  |  1  0  0  tx  |
    ' T_translation =  |  0  1  0  ty  |
    '                  |  0  0  1  tz  |
    '                  |  0  0  0   1  |
    Public Function TranslateTransformation(trans_x As Double, trans_y As Double, trans_z As Double) As Matrix(Of Double)
        Return Matrix(Of Double).Build.Dense(4, 4, {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, trans_x, trans_y, trans_z, 1})
    End Function

    ''' <summary>
    ''' Inverse Kinematics of smarpod with Pivot mode relative
    ''' </summary>
    ''' <param name="htm"> (4x4) homogenous transformation matrix</param>
    ''' <returns> (6x1) matrix</returns>
    ''' <remarks></remarks>
    Public Function smarpod_relative_inverse(htm As Matrix(Of Double)) As Matrix(Of Double)
        Dim x, y, z, theta_x, theta_y, theta_z As Double
        x = htm(0, 3)
        y = htm(1, 3)
        z = htm(2, 3)
        theta_x = Math.Atan2(htm(2, 1), htm(2, 2))
        theta_y = Math.Asin(-htm(2, 0))
        theta_z = Math.Atan2(htm(1, 0), htm(0, 0))

        Return Matrix(Of Double).Build.Dense(6, 1, {x, y, z, theta_x, theta_y, theta_z})
    End Function

    ''' <summary>
    ''' Forward Kinematics of smarpod with Pivot mode relative
    ''' </summary>
    ''' <param name="mat_pos"> (6x1) matrix of smarpod posture</param>
    ''' <returns> (4x4) htm of smarpod </returns>
    ''' <remarks></remarks>
    Public Function smarpod_relative_forward(mat_pos As Matrix(Of Double)) As Matrix(Of Double)
        Return RotateTransformation(mat_pos(3, 0), mat_pos(4, 0), mat_pos(5, 0)) * TranslateTransformation(mat_pos(0, 0), mat_pos(1, 0), mat_pos(2, 0))
    End Function
    Public Function smarpod_relative_forward(x As Double, y As Double, z As Double, theta_x As Double, theta_y As Double, theta_z As Double) As Matrix(Of Double)
        Return RotateTransformation(theta_x, theta_y, theta_z) * TranslateTransformation(x, y, z)
    End Function

    ''' <summary>
    ''' Forward Kinematics of smarpod with Pivot mode fixed
    ''' </summary>
    ''' <param name="mat_pos">(6x1) matrix of smarpod posture</param>
    ''' <returns> (4x4) htm of smarpod </returns>
    ''' <remarks></remarks>
    Public Function smarpod_fixed_forward(mat_pos As Matrix(Of Double)) As Matrix(Of Double)
        Return TranslateTransformation(mat_pos(0, 0), mat_pos(1, 0), mat_pos(2, 0)) * RotateTransformation(mat_pos(3, 0), mat_pos(4, 0), mat_pos(5, 0))
    End Function
    Public Function smarpod_fixed_forward(x As Double, y As Double, z As Double, theta_x As Double, theta_y As Double, theta_z As Double) As Matrix(Of Double)
        Return TranslateTransformation(x, y, z) * RotateTransformation(theta_x, theta_y, theta_z)
    End Function

    Public Function LoadMatrix(strFileName As String) As Matrix(Of Double)
        Try
            Return DelimitedReader.Read(Of Double)(strFileName, False, ",")
        Catch ex As Exception
            MessageBox.Show(ex.Message)
        End Try        
        Return Nothing
    End Function

    Public Function SaveMatrix(strFileName As String, mat As Matrix(Of Double)) As Boolean
        Try
            DelimitedWriter.Write(Of Double)(strFileName, mat, ",")
            Return True
        Catch ex As Exception
            MessageBox.Show(ex.Message)
        End Try
        Return False
    End Function

End Module

Public Class CalibrationChain
    
    Public tolerance As Double = 0.001

    Private __nominal As MechanismNominal = New MechanismNominal
    Private __serializer As XmlSerializer = New XmlSerializer(GetType(MechanismNominal))

    Private stack_deltaPC1 As Matrix(Of Double) = Nothing
    Private stack_ErrorCoefficient As Matrix(Of Double) = Nothing

    ' unknown
    Private Error_C(3) As Matrix(Of Double)         ' (6x1)
    Private T_Ci_Cr(3) As Matrix(Of Double)         ' (4x4)

    ' known
    Private __T_R_C(3) As Matrix(Of Double)         ' (4x4)
    Private __T_S0_R As Matrix(Of Double)           ' (4x4)
    Private __T_S_S0 As Matrix(Of Double)           ' (4x4)
    Private __P_B As Matrix(Of Double)              ' (4x1)


    Public Sub initialize()
        Error_C(1) = Matrix(Of Double).Build.Dense(6, 1, {0, 0, 0, 0, 0, 0})
        Error_C(2) = Matrix(Of Double).Build.Dense(6, 1, {0, 0, 0, 0, 0, 0})
        Error_C(3) = Matrix(Of Double).Build.Dense(6, 1, {0, 0, 0, 0, 0, 0})
        T_Ci_Cr(1) = Matrix(Of Double).Build.DenseDiagonal(4, 1.0)
        T_Ci_Cr(2) = Matrix(Of Double).Build.DenseDiagonal(4, 1.0)
        T_Ci_Cr(3) = Matrix(Of Double).Build.DenseDiagonal(4, 1.0)

        Try
            __T_R_C(1) = MatrixOperation.LoadMatrix("Data\T_R_C1.txt")
            __T_R_C(2) = MatrixOperation.LoadMatrix("Data\T_R_C2.txt")
            __T_R_C(3) = MatrixOperation.LoadMatrix("Data\T_R_C3.txt")
            __T_S0_R = MatrixOperation.LoadMatrix("Data\T_S0_R.txt")
            __T_S_S0 = MatrixOperation.LoadMatrix("Data\T_S_S0.txt")
            __P_B = MatrixOperation.LoadMatrix("Data\P_B.txt")
        Catch ex As Exception
            MessageBox.Show(ex.Message)
        End Try

    End Sub

    Public Sub SaveNominal()
        Using sw As StreamWriter = New StreamWriter("Data\MechanismNominal.xml")
            __serializer.Serialize(sw, __nominal)
        End Using
    End Sub

    Public Sub LoadNominal()
        Using sr As StreamReader = New StreamReader("Data\MechanismNominal.xml")
            __nominal = __serializer.Deserialize(sr)
        End Using
    End Sub

    Public Function T_S_S0(mat_Pod As Matrix(Of Double)) As Matrix(Of Double)
        Return MatrixOperation.smarpod_fixed_forward(mat_Pod)
    End Function

    Public Function T_S0_R(Ax As Double) As Matrix(Of Double)
        __T_S0_R(0, 3) = __T_S0_R(0, 3) + Ax
        Return __T_S0_R
    End Function

    ''' <summary>
    ''' Ideal P_C (4x1 Matrix)
    ''' </summary>
    ''' <param name="camera_i"></param>
    ''' <param name="Ax"></param>
    ''' <param name="mat_Pod"> (6x1) matrix of pod posture</param>
    ''' <param name="P_B"> (4x1) matrix of point</param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Public Function P_Ci_ideal(camera_i As Integer, Ax As Double, mat_Pod As Matrix(Of Double), P_B As Matrix(Of Double)) As Matrix(Of Double)
        Return T_Ci_Cr(camera_i) * __T_R_C(camera_i) * T_S0_R(Ax) * T_S_S0(mat_Pod) * P_B
    End Function

    ''' <summary>
    ''' Difference between P_C_ideal and P_C_real (2x1 Matrix)
    ''' </summary>
    ''' <param name="mat_ideal"> 2x1 matrix</param>
    ''' <param name="mat_real"> 2x1 matrix</param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Public Function P_C_Error(mat_ideal As Matrix(Of Double), mat_real As Matrix(Of Double)) As Matrix(Of Double)
        Return mat_ideal - mat_real
    End Function

    ''' <summary>
    ''' Error Coefficient Matrix of C
    ''' </summary>
    ''' <param name="Ax"></param>
    ''' <param name="mat_Pod">(6x1) matrix of pod posture</param>
    ''' <returns>(2x6) error coefficient matrix</returns>
    ''' <remarks></remarks>
    Public Function ErrorCoefficient_C(camera_i As Integer, Ax As Double, mat_Pod As Matrix(Of Double)) As Matrix(Of Double)

        Dim C1x As Double = __nominal.C1x
        Dim C1y As Double = __nominal.C1y
        Dim C1z As Double = __nominal.C1z
        Dim C2x As Double = __nominal.C2x
        Dim C2y As Double = __nominal.C2y
        Dim C2z As Double = __nominal.C2z
        Dim C3x As Double = __nominal.C3x
        Dim C3y As Double = __nominal.C3y
        Dim C3z As Double = __nominal.C3z
        Dim Px As Double = __P_B(0, 0)
        Dim Py As Double = __P_B(1, 0)
        Dim Pz As Double = __P_B(2, 0)
        Dim S0X As Double = __nominal.S0x
        Dim S0Y As Double = __nominal.S0y
        Dim S0Z As Double = __nominal.S0z
        Dim Sx As Double = mat_Pod(0, 0)
        Dim Sy As Double = mat_Pod(1, 0)
        Dim Sz As Double = mat_Pod(2, 0)

        Select Case camera_i
            Case 1
                Return Matrix(Of Double).Build.DenseOfArray({{-1, 0, 0, 0, (-Ax + C1x + Px + Sx), (-C1z - Pz + S0Z - Sz)},
                                                     {0, -1, 0, (Ax - C1x - Pz - Sx), 0, (-C1y + Py + S0Y + Sy)}})
                ' C1 error analysis (x, y, z, rx, ry, rz)
                '   |   -1      0       0           0         (-Ax+C1x+Px+Sx)     (-C1z-Pz+S0Z-Sz)  |
                '   |    0     -1       0    (Ax-C1x-Pz-Sx)          0            (-C1y+Py+S0Y+Sy)  |
            Case 2
                Return Matrix(Of Double).Build.DenseOfArray({{-1, 0, 0, 0, (C2y - Py - S0Y - Sy), (C2z + Pz - S0Z + Sz)},
                                                     {0, -1, 0, (-C2y + Py + S0Y + Sy), 0, (-Ax + C2x + Px + Sx)}})
                ' C2 error analysis
                '   |   -1      0       0           0         (C2y-Py-S0Y-Sy)      (C2z+Pz-S0Z+Sz)  |
                '   |    0     -1       0   (-C2y+Py+S0Y+Sy)         0             (-Ax+C2x+Px+Sx)  |
            Case 3
                Return Matrix(Of Double).Build.DenseOfArray({{-1, 0, 0, 0, (C3z + Pz - S0Z + Sz), (-C3y + Py + S0Y + Sy)},
                                                     {0, -1, 0, (-C3z - Pz + S0Z - Sz), 0, (-Ax + C3x + Px + Sx)}})
                ' C3 error analysis
                '   |   -1      0       0           0          (C3z+Pz-S0Z+Sz)     (-C3y+Py+S0Y+Sy) |
                '   |    0     -1       0    (-C3z-Pz+S0Z-Sz)        0              (-Ax+C3x+Px+Sx) |
            Case Else
                Return Nothing
        End Select
    End Function

    ''' <summary>
    ''' T_ideal_real
    ''' </summary>
    ''' <param name="mat_error"> (6x1) matrix of error between ideal and real</param>
    ''' <returns> (4x4) error transformation matrix </returns>
    ''' <remarks></remarks>
    Public Function T_ideal_real(mat_error As Matrix(Of Double)) As Matrix(Of Double)
        Dim sx As Double = mat_error(0, 0)
        Dim sy As Double = mat_error(1, 0)
        Dim sz As Double = mat_error(2, 0)
        Dim ex As Double = mat_error(3, 0)
        Dim ey As Double = mat_error(4, 0)
        Dim ez As Double = mat_error(5, 0)
        Return Matrix(Of Double).Build.DenseOfArray({{1, -ez, ey, sx}, {ez, 1, -ex, sy}, {-ey, ex, 1, sz}, {0, 0, 0, 0}})
        ' T_ideal_real
        '   |   1       -ezy0   eyy0    sxy0    |
        '   |   ezy0    1       -exy0   syy0    |
        '   |   -eyy0   exy0    1       szy0    |
        '   |   0       0       0       1       |
    End Function

    ''' <summary>
    ''' iterate Error transformation matrix
    ''' </summary>
    ''' <param name="list_PodPosture"> n postures of smarpod </param>
    ''' <param name="list_PC_real"> n points measured by camera </param>
    ''' <param name="Ax"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Public Function IterateErrorTransMatrix(camera_i As Integer, list_PodPosture As List(Of Matrix(Of Double)), list_PC_real As List(Of Matrix(Of Double)), Ax As Double) As Integer
        Dim newError_C As Matrix(Of Double)
        Dim diff As Double = 1.0

        While (diff > tolerance)

            For i = 0 To list_PodPosture.Count
                stackErrorMatrix(camera_i, list_PodPosture(i), Ax, list_PC_real(i))
            Next

            newError_C = MatrixOperation.PseudoInverse(stack_ErrorCoefficient) * stack_deltaPC1
            T_Ci_Cr(camera_i) = T_ideal_real(Error_C(camera_i))

            diff = Error_C(camera_i).FrobeniusNorm() - newError_C.FrobeniusNorm()

            Error_C(camera_i) = newError_C
        End While

        Return 0
    End Function

    Public Sub stackErrorMatrix(camera_i As Integer, mat_Pod As Matrix(Of Double), Ax As Double, P_C_real As Matrix(Of Double))
        ' delta_P_C = CoefficientMatrix * ErrorMatrix

        If stack_deltaPC1 Is Nothing Then
            stack_deltaPC1 = Matrix(Of Double).Build.DenseOfMatrix(P_C_Error(P_Ci_ideal(1, Ax, mat_Pod, __P_B).SubMatrix(0, 2, 0, 1), P_C_real))
        Else
            stack_deltaPC1.Stack(P_C_Error(P_Ci_ideal(1, Ax, mat_Pod, __P_B).SubMatrix(0, 2, 0, 1), P_C_real))
        End If

        If stack_ErrorCoefficient Is Nothing Then
            stack_ErrorCoefficient = ErrorCoefficient_C(camera_i, Ax, mat_Pod)
        Else
            stack_ErrorCoefficient.Stack(ErrorCoefficient_C(camera_i, Ax, mat_Pod))
        End If

    End Sub

End Class

<Serializable>
Public Class MechanismNominal
    Property C1x As Double
    Property C1y As Double
    Property C1z As Double
    Property C2x As Double
    Property C2y As Double
    Property C2z As Double
    Property C3x As Double
    Property C3y As Double
    Property C3z As Double
    Property C4x As Double
    Property C4y As Double
    Property C4z As Double
    Property S0x As Double
    Property S0y As Double
    Property S0z As Double
    Property Y0x As Double
    Property Y0y As Double
    Property Y0z As Double
    Property Lx As Double
    Property Ly As Double
    Property Lz As Double
End Class
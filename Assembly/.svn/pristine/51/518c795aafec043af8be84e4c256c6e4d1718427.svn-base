Imports MathNet.Numerics.LinearAlgebra
Imports System.Xml.Serialization
Imports System.IO
Imports AutoNumeric
Imports FA.framesDefinition
''' <summary>
''' List all Frame Tag
''' </summary>
''' <remarks></remarks>
Public Enum framesDefinition As Byte
    R = 0
    C1
    C2
    C3
    C1REAL
    C2REAL
    C3REAL
    S0
    S
    Y0
    Y0REAL
    C4
    L
    LREAL
End Enum


''' <summary>
''' Depict machine frame structure
''' </summary>
''' <remarks></remarks>
Public Class frames
    Inherits kinematicGraphBase
    Implements IDisposable

    ReadOnly Property T_s0_r As s0Htm
        Get
            Return s0Htm.Instance
        End Get
    End Property
    ReadOnly Property T_c4_y0real As c4htm
        Get
            Return c4htm.Instance
        End Get
    End Property

    ''' <summary>
    ''' Store the positions of objects on reference frame
    ''' </summary>
    ''' <remarks></remarks>
    Friend objectsList As Dictionary(Of itemsDefinition, PositionVector) = New Dictionary(Of itemsDefinition, PositionVector)

    ''' <summary>
    ''' Given item , solve the nominal axis value
    ''' TODO , test
    ''' </summary>
    ''' <param name="rItem"></param>
    ''' <param name="movingItem"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Function solveAbsAxAy(rItem As itemsDefinition, movingItem As framesDefinition) As Object
        Select Case movingItem
            Case L, C4, S0
                Dim origin As PositionVector = New PositionVector(movingItem)
                'calculated target translation
                Dim currentTransformation = Transformation(movingItem, R)

                Dim targetTranslation =
                  objectsList(rItem).RawValue.SubVector(0, 3) - currentTransformation.RotationMatrix * origin.RawValue.SubVector(0, 3)

                Dim xIncrement = targetTranslation(0) - currentTransformation.Origin.X
                Dim yIncrement = targetTranslation(1) - currentTransformation.Origin.Y

                'update Ax,Ay
                T_s0_r.AxFromHome += xIncrement
                T_c4_y0real.AyFromHome += yIncrement

                Return {T_s0_r.AxFromHome, T_c4_y0real.AyFromHome}

            Case Else
                'not available Y item
                Throw New InvalidDataException
        End Select
    End Function

    Function initialize() As Integer

        're-construct chain from persistance
        With Me.__htmEdgeList
            .Add(New htmEdgeElementary(C1, R))
            .Add(New htmEdgeElementary(C2, R))
            .Add(New htmEdgeElementary(C3, R))

            .Add(New errorHtm(C1REAL, C1))
            .Add(New errorHtm(C2REAL, C2))
            .Add(New errorHtm(C3REAL, C3))

            .Add(s0Htm.Instance)
            .Add(New eulerHtmTR(S, S0))

            .Add(New htmEdgeElementary(Y0, S0))
            .Add(New errorHtm(Y0REAL, Y0))

            .Add(c4htm.Instance)

            .Add(New htmEdgeElementary(L, C4))
            .Add(New errorHtm(LREAL, L))

            Dim __listNeedReload = .FindAll(Function(__htm As htmEdgeElementary) __htm.GetType.Equals(GetType(htmEdgeElementary)))
            __listNeedReload.AddRange({s0Htm.Instance,
                                       c4htm.Instance})
            __listNeedReload.ForEach(Sub(__htm As htmEdgeElementary) __htm.Load(Nothing))

        End With
        'reconstruct object list
        Dim valueArray = [Enum].GetValues(GetType(itemsDefinition))
        For index = 0 To valueArray.Length - 1
            Dim item As itemsDefinition = [Enum].ToObject(GetType(itemsDefinition), valueArray(index))
            objectsList.Add(item, New PositionVector(R, item.ToString))
        Next
        'reload
        For Each item As PositionVector In objectsList.Values
            item.Load(Nothing)
        Next
        'except these (consisted with frame define)
        objectsList(itemsDefinition.C3_ORIGIN).RawValue = Me.Elementray(C3, R).PositionVector

        Return 0
    End Function

    ''' <summary>
    ''' Singleton mode
    ''' </summary>
    ''' <remarks></remarks>
    Protected Sub New()

    End Sub

    Shared ReadOnly Property Instance As frames
        Get
            Return __instance
        End Get
    End Property
    Shared __instance As frames = New frames

#Region "IDisposable Support"
    Private disposedValue As Boolean ' To detect redundant calls

    ' IDisposable
    Protected Overridable Sub Dispose(disposing As Boolean)
        If Not Me.disposedValue Then
            If disposing Then
                ' TODO: dispose managed state (managed objects).
            End If

            ' TODO: free unmanaged resources (unmanaged objects) and override Finalize() below.
            ' TODO: set large fields to null.
        End If

        'TODO , for those marked persistance , do save()

        Me.disposedValue = True
    End Sub

    ' TODO: override Finalize() only if Dispose(ByVal disposing As Boolean) above has code to free unmanaged resources.
    Protected Overrides Sub Finalize()
        ' Do not change this code.  Put cleanup code in Dispose(ByVal disposing As Boolean) above.
        Dispose(False)
        MyBase.Finalize()
    End Sub

    ' This code added by Visual Basic to correctly implement the disposable pattern.
    Public Sub Dispose() Implements IDisposable.Dispose
        ' Do not change this code.  Put cleanup code in Dispose(disposing As Boolean) above.
        Dispose(True)
        GC.SuppressFinalize(Me)
    End Sub
#End Region

End Class


Imports MathNet.Numerics.LinearAlgebra
Imports System.Xml.Serialization
Imports System.IO
Imports AutoNumeric
Imports FA.framesDefinition
Imports System.Runtime.CompilerServices
Imports System.ComponentModel
<Assembly: InternalsVisibleTo("AssemblyTester")> 

''' <summary>
''' List all Frame Tag
''' </summary>
''' <remarks></remarks>
Public Enum framesDefinition As Byte
    R = 0
    C1
    C2
    C3
    C1REAL
    C2REAL
    C3REAL
    S0
    S
    Y0
    Y0REAL
    C4
    L
    LREAL

    LPC
    BALL

    DIE
End Enum


''' <summary>
''' Depict machine frame structure
''' </summary>
''' <remarks></remarks>
Public Class frames
    Inherits kinematicGraphBase
    Implements IDisposable

    Public Property CurrentRItem As itemsDefinition
        Get
            Return __currentRItem
        End Get
        Set(ByVal value As itemsDefinition)
            __currentRItem = value
            solveAbsAxAy(__currentRItem, __currentMovingItem)
        End Set
    End Property
    ReadOnly Property CurrentRObject As PositionVector
        Get
            Return objectsDictionary(__currentRItem)
        End Get
    End Property
    ReadOnly Property HtmsNeedReload As List(Of htmEdgeBase)
        Get
            Return __htmsNeedReload
        End Get
    End Property

    Public Property CurrentMovingItem As framesDefinition
        Get
            Return __currentMovingItem
        End Get
        Set(ByVal value As framesDefinition)
            Select Case value
                Case L, C4, S0
                    __currentMovingItem = value
                    'solveAbsAxAy(__currentRItem, __currentMovingItem)
                Case Else
                    'reject
            End Select

        End Set
    End Property

    Dim __currentMovingItem As framesDefinition = S0
    Dim __currentRItem As itemsDefinition = itemsDefinition.CHOKE_CENTER


    ''' <summary>
    ''' Store the positions of objects on reference frame
    ''' </summary>
    ''' <remarks></remarks>
    Friend objectsDictionary As Dictionary(Of itemsDefinition, PositionVector) = New Dictionary(Of itemsDefinition, PositionVector)

    Dim __htmsNeedReload As List(Of htmEdgeBase) = New List(Of htmEdgeBase)


    ''' <summary>
    ''' Match the moving item origin to target item
    ''' Given item , solve the nominal axis value
    ''' </summary>
    ''' <param name="rItem"></param>
    ''' <param name="movingItem"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Friend Function solveAbsAxAy(rItem As itemsDefinition, movingItem As framesDefinition) As Object
        Return solveAbsAxAy(objectsDictionary(rItem), movingItem)
    End Function

    ''' <summary>
    ''' Move moving item to targetPosition represented in R-frame
    ''' </summary>
    ''' <param name="targetPosition">
    ''' Position In R-Frame
    ''' </param>
    ''' <param name="movingItem"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Friend Function solveAbsAxAy(targetPosition As PositionVector, movingItem As framesDefinition) As Object
        Select Case movingItem
            Case L, C4, S0
                Dim origin As PositionVector = New PositionVector(movingItem)
                'calculated target translation
                Dim currentTransformation = Transformation(movingItem, R)

                'moving item to R
                Dim targetTranslation =
                  targetPosition.RawValue.SubVector(0, 3) - currentTransformation.RotationMatrix * origin.RawValue.SubVector(0, 3)

                Dim xIncrement = targetTranslation(axisEntityEnum.X) - currentTransformation.Origin.X
                Dim yIncrement = targetTranslation(axisEntityEnum.Y) - currentTransformation.Origin.Y

                'update Ax,Ay (moving?
                s0Htm.Instance.AxisValue(axisEntityEnum.X) += xIncrement
                If Not movingItem.Equals(S0) Then
                    c4htm.Instance.AxisValue(axisEntityEnum.Y) += yIncrement
                End If

                Return {s0Htm.Instance.AxisValue(axisEntityEnum.X),
                        c4htm.Instance.AxisValue(axisEntityEnum.Y)}

            Case Else
                'not available Y item
                Throw New InvalidDataException
        End Select
    End Function

    ''' <summary>
    ''' Manipulate Ax,Ay , let fixed item moving under view of moving carriage
    ''' </summary>
    ''' <param name="targetPositionInMovingItem"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Friend Function solveAbsAxAy(targetPositionInMovingItem As PositionVector) As Object
        Dim targetPositionInR = Transformation(targetPositionInMovingItem.ReferencedFrame, framesDefinition.R) * targetPositionInMovingItem
        Return solveAbsAxAy(targetPositionInR, CType(targetPositionInMovingItem.ReferencedFrame, framesDefinition))
    End Function

    ' ''' <summary>
    ' ''' Move tool(on S-Frame) to coincidence workpiece(?-Frame, follow the workpiece)
    ' ''' </summary>
    ' ''' <param name="tool"></param>
    ' ''' <param name="workpiece"></param>
    ' ''' <returns></returns>
    ' ''' <remarks></remarks>
    'Function solveSFixedPose(tool As PositionVector, workpiece As PositionVector) As Integer
    '    'Fetch T_S_?
    '    Dim currentTransformation = Transformation(framesDefinition.S, workpiece.ReferencedFrame)
    '    Dim targetTranslation =
    '        workpiece.RawValue.SubVector(0, 3) - currentTransformation.RotationMatrix * tool.RawValue.SubVector(0, 3)

    '    'update S control vector
    '    With sHtm.Instance
    '        'update and trigger
    '        .PositionVector = CreateVector.Dense(Of Double)({targetTranslation(axisEntityEnum.X),
    '                                                         targetTranslation(axisEntityEnum.Y),
    '                                                         targetTranslation(axisEntityEnum.Z),
    '                                                         1})
    '    End With

    '    Return 0
    'End Function


    Public Enum manipulationOptionsEnum
        POSITION_ONLY = &H1
        ROTATION_ONLY = &H2
        BOTH = &H3
    End Enum


    ''' <summary>
    ''' Manipulate some frame on specific reference
    ''' </summary>
    ''' <remarks></remarks>
    Function solveS(transformationToolToWorkpiece As htmEdgeBase,
                    Optional manipulationOptions As manipulationOptionsEnum = manipulationOptionsEnum.BOTH) As Object

        'chain,  T_s_s0 = T_r_s0 * T_w_r * T_s_w
        'target transformation (T_w_r
        Dim transformationStoTool = Transformation(framesDefinition.S, transformationToolToWorkpiece.From)
        Dim transformationWorkpiecetoS0 = Transformation(transformationToolToWorkpiece.To__, framesDefinition.S0)
        Dim transformationStoS0 = transformationWorkpiecetoS0 * transformationToolToWorkpiece * transformationStoTool


        'update S control vector
        With sHtm.Instance
            Select Case manipulationOptions
                Case manipulationOptionsEnum.POSITION_ONLY
                    .PositionVector = transformationStoS0.PositionVector
                Case manipulationOptionsEnum.ROTATION_ONLY
                    .RotationMatrix = transformationStoS0.RotationMatrix
                Case manipulationOptionsEnum.BOTH
                    'update and trigger
                    .RawValue = transformationStoS0.RawValue
            End Select

            Return .ControlVector
        End With

    End Function


    Protected Sub New()

        're-construct chain from persistance
        With Me.__htmEdgeList
            .Add(New htmEdgeElementary(C1, R))
            .Add(New htmEdgeElementary(C2, R))
            .Add(New htmEdgeElementary(C3, R))

            .Add(New errorHtm(C1REAL, C1))
            .Add(New errorHtm(C2REAL, C2))
            .Add(New errorHtm(C3REAL, C3))

            .Add(s0Htm.Instance)
            .Add(sHtm.Instance)

            .Add(New htmEdgeElementary(Y0, S0))
            .Add(New errorHtm(Y0REAL, Y0))

            .Add(c4htm.Instance)

            .Add(New htmEdgeElementary(L, C4))
            .Add(New errorHtm(LREAL, L))

            .Add(New htmEdgeElementary(LPC, S))
            .Add(New htmEdgeElementary(BALL, S))

            .Add(New htmEdgeElementary(DIE, R))

            With __htmsNeedReload
                .AddRange(Me.__htmEdgeList.FindAll(Function(__htm As htmEdgeElementary) __htm.GetType.Equals(GetType(htmEdgeElementary))))
                .AddRange({s0Htm.Instance,
                           c4htm.Instance})
                .ForEach(Sub(__htm As htmEdgeElementary) __htm.Load(Nothing))
            End With
        End With
        'reconstruct object list
        Dim valueArray = [Enum].GetValues(GetType(itemsDefinition))
        For index = 0 To valueArray.Length - 1
            Dim item As itemsDefinition = [Enum].ToObject(GetType(itemsDefinition), valueArray(index))
            Dim attribute = CType(item.GetType.GetMember(item.ToString).First.GetCustomAttributes(GetType(reference), False).First, reference)
            objectsDictionary.Add(item, New PositionVector(attribute.ReferencedFrame, item.ToString))
        Next
        'reload
        For Each item As PositionVector In objectsDictionary.Values
            item.Load(Nothing)
        Next
        'except these (consisted with frame define)
        objectsDictionary(itemsDefinition.C1_ORIGIN).RawValue = Me.Elementray(C1, R).PositionVector
        objectsDictionary(itemsDefinition.C2_ORIGIN).RawValue = Me.Elementray(C2, R).PositionVector
        objectsDictionary(itemsDefinition.C3_ORIGIN).RawValue = Me.Elementray(C3, R).PositionVector


    End Sub

    Shared ReadOnly Property Instance As frames
        Get
            If __instance Is Nothing Then
                __instance = New frames
            End If
            Return __instance
        End Get
    End Property
    Shared __instance As frames = Nothing

#Region "IDisposable Support"
    Private disposedValue As Boolean ' To detect redundant calls

    ' IDisposable
    Protected Overridable Sub Dispose(disposing As Boolean)
        If Not Me.disposedValue Then
            If disposing Then
                ' TODO: dispose managed state (managed objects).
            End If

            ' TODO: free unmanaged resources (unmanaged objects) and override Finalize() below.
            ' TODO: set large fields to null.
        End If

        'for those marked persistance , do save()
        __htmsNeedReload.ForEach(Sub(htm As htmEdgeElementary) htm.Save())
        For Each item As PositionVector In objectsDictionary.Values
            item.Save()
        Next

        Me.disposedValue = True
    End Sub

    ' TODO: override Finalize() only if Dispose(ByVal disposing As Boolean) above has code to free unmanaged resources.
    Protected Overrides Sub Finalize()
        ' Do not change this code.  Put cleanup code in Dispose(ByVal disposing As Boolean) above.
        Dispose(False)
        MyBase.Finalize()
    End Sub

    ' This code added by Visual Basic to correctly implement the disposable pattern.
    Public Sub Dispose() Implements IDisposable.Dispose
        ' Do not change this code.  Put cleanup code in Dispose(disposing As Boolean) above.
        Dispose(True)
        GC.SuppressFinalize(Me)
    End Sub
#End Region

End Class


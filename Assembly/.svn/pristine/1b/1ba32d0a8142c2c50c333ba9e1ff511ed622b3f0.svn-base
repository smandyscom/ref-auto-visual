Imports MathNet.Numerics.LinearAlgebra
Imports System.Xml.Serialization
Imports System.IO
Imports AutoNumeric
Imports FA.framesDefinition
Imports System.Runtime.CompilerServices
Imports System.ComponentModel
<Assembly: InternalsVisibleTo("AssemblyTester")> 

''' <summary>
''' List all Frame Tag
''' </summary>
''' <remarks></remarks>
Public Enum framesDefinition As Byte
    R = 0
    C1
    C2
    C3
    C1REAL
    C2REAL
    C3REAL
    S0
    S
    Y0
    Y0REAL
    C4
    L
    LREAL
End Enum


''' <summary>
''' Depict machine frame structure
''' </summary>
''' <remarks></remarks>
Public Class frames
    Inherits kinematicGraphBase
    Implements IDisposable

    Public Property CurrentRItem As itemsDefinition
        Get
            Return __currentRItem
        End Get
        Set(ByVal value As itemsDefinition)
            __currentRItem = value
            solveAbsAxAy(__currentRItem, __currentMovingItem)
        End Set
    End Property
    ReadOnly Property CurrentRObject As PositionVector
        Get
            Return objectsDictionary(__currentRItem)
        End Get
    End Property
    ReadOnly Property HtmsNeedReload As List(Of htmEdgeBase)
        Get
            Return __htmsNeedReload
        End Get
    End Property


    Public Property CurrentMovingItem As framesDefinition
        Get
            Return __currentMovingItem
        End Get
        Set(ByVal value As framesDefinition)
            Select Case value
                Case L, C4, S0
                    __currentMovingItem = value
                    solveAbsAxAy(__currentRItem, __currentMovingItem)
                Case Else
                    'reject
            End Select

        End Set
    End Property

    Dim __currentMovingItem As framesDefinition = S0
    Dim __currentRItem As itemsDefinition = itemsDefinition.CHOKE_CENTER


    ''' <summary>
    ''' Store the positions of objects on reference frame
    ''' </summary>
    ''' <remarks></remarks>
    Friend objectsDictionary As Dictionary(Of itemsDefinition, PositionVector) = New Dictionary(Of itemsDefinition, PositionVector)

    Dim __htmsNeedReload As List(Of htmEdgeBase) = New List(Of htmEdgeBase)


    ''' <summary>
    ''' Given item , solve the nominal axis value
    ''' 
    ''' TODO , test
    ''' </summary>
    ''' <param name="rItem"></param>
    ''' <param name="movingItem"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Friend Function solveAbsAxAy(rItem As itemsDefinition, movingItem As framesDefinition) As Object
        Select Case movingItem
            Case L, C4, S0
                Dim origin As PositionVector = New PositionVector(movingItem)
                'calculated target translation
                Dim currentTransformation = Transformation(movingItem, R)

                Dim targetTranslation =
                  objectsDictionary(rItem).RawValue.SubVector(0, 3) - currentTransformation.RotationMatrix * origin.RawValue.SubVector(0, 3)

                Dim xIncrement = targetTranslation(0) - currentTransformation.Origin.X
                Dim yIncrement = targetTranslation(1) - currentTransformation.Origin.Y

                'update Ax,Ay (moving?
                s0Htm.Instance.AxisValue(axisEntityEnum.X) += xIncrement
                c4htm.Instance.AxisValue(axisEntityEnum.Y) += yIncrement

                Return {s0Htm.Instance.AxisValue(axisEntityEnum.X),
                        c4htm.Instance.AxisValue(axisEntityEnum.Y)}

            Case Else
                'not available Y item
                Throw New InvalidDataException
        End Select
    End Function

    ''' <summary>
    ''' Move tool(S-Frame) to coincidence workpiece(?-Frame, follow the workpiece)
    ''' </summary>
    ''' <param name="tool"></param>
    ''' <param name="workpiece"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Function solveSFixedPose(tool As PositionVector, workpiece As PositionVector) As Integer
        'Fetch T_S_?
        Dim currentTransformation = Transformation(framesDefinition.S, workpiece.ReferencedFrame)
        Dim targetTranslation =
            workpiece.RawValue.SubVector(0, 3) - currentTransformation.RotationMatrix * tool.RawValue.SubVector(0, 3)

        'update S control vector

        Return 0
    End Function


    Protected Sub New()

        're-construct chain from persistance
        With Me.__htmEdgeList
            .Add(New htmEdgeElementary(C1, R))
            .Add(New htmEdgeElementary(C2, R))
            .Add(New htmEdgeElementary(C3, R))

            .Add(New errorHtm(C1REAL, C1))
            .Add(New errorHtm(C2REAL, C2))
            .Add(New errorHtm(C3REAL, C3))

            .Add(s0Htm.Instance)
            .Add(sHtm.Instance)

            .Add(New htmEdgeElementary(Y0, S0))
            .Add(New errorHtm(Y0REAL, Y0))

            .Add(c4htm.Instance)

            .Add(New htmEdgeElementary(L, C4))
            .Add(New errorHtm(LREAL, L))

            With __htmsNeedReload
                .AddRange(Me.__htmEdgeList.FindAll(Function(__htm As htmEdgeElementary) __htm.GetType.Equals(GetType(htmEdgeElementary))))
                .AddRange({s0Htm.Instance,
                           c4htm.Instance})
                .ForEach(Sub(__htm As htmEdgeElementary) __htm.Load(Nothing))
            End With
        End With
        'reconstruct object list
        Dim valueArray = [Enum].GetValues(GetType(itemsDefinition))
        For index = 0 To valueArray.Length - 1
            Dim item As itemsDefinition = [Enum].ToObject(GetType(itemsDefinition), valueArray(index))
            objectsDictionary.Add(item, New PositionVector(R, item.ToString))
        Next
        'reload
        For Each item As PositionVector In objectsDictionary.Values
            item.Load(Nothing)
        Next
        'except these (consisted with frame define)
        objectsDictionary(itemsDefinition.C3_ORIGIN).RawValue = Me.Elementray(C3, R).PositionVector

    End Sub

    Shared ReadOnly Property Instance As frames
        Get
            Return __instance
        End Get
    End Property
    Shared __instance As frames = New frames

#Region "IDisposable Support"
    Private disposedValue As Boolean ' To detect redundant calls

    ' IDisposable
    Protected Overridable Sub Dispose(disposing As Boolean)
        If Not Me.disposedValue Then
            If disposing Then
                ' TODO: dispose managed state (managed objects).
            End If

            ' TODO: free unmanaged resources (unmanaged objects) and override Finalize() below.
            ' TODO: set large fields to null.
        End If

        'for those marked persistance , do save()
        __htmsNeedReload.ForEach(Sub(htm As htmEdgeElementary) htm.Save())
        For Each item As PositionVector In objectsDictionary.Values
            item.Save()
        Next

        Me.disposedValue = True
    End Sub

    ' TODO: override Finalize() only if Dispose(ByVal disposing As Boolean) above has code to free unmanaged resources.
    Protected Overrides Sub Finalize()
        ' Do not change this code.  Put cleanup code in Dispose(ByVal disposing As Boolean) above.
        Dispose(False)
        MyBase.Finalize()
    End Sub

    ' This code added by Visual Basic to correctly implement the disposable pattern.
    Public Sub Dispose() Implements IDisposable.Dispose
        ' Do not change this code.  Put cleanup code in Dispose(disposing As Boolean) above.
        Dispose(True)
        GC.SuppressFinalize(Me)
    End Sub
#End Region

End Class


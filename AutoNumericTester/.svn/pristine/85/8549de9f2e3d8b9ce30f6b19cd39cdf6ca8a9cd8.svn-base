Imports Microsoft.VisualStudio.TestTools.UnitTesting

Imports AutoNumeric
Imports MathNet.Numerics.LinearAlgebra
Imports AutoNumeric.fittingMethods
Imports AutoNumericTester.commonNamespace AutoNumeric.Tests
    <TestClass()> Public Class fittingMethodsTests



        <TestMethod()> Public Sub parabolicFittingTest()

            Dim answerCoeff As Vector(Of Double) = CreateVector.Random(Of Double)(3)
            Dim pointCounts As Integer = 20

            Dim pointSets As List(Of Vector(Of Double)) = New List(Of Vector(Of Double))

            For index = 0 To pointCounts - 1

                Dim __pt As Vector(Of Double) = CreateVector.Dense(Of Double)(2)
                __pt(variableDefinition.INDEPENDENT) = index
                __pt(variableDefinition.DEPENDENT) = Math.Pow(index, 2) * answerCoeff(0) + index * answerCoeff(1) + answerCoeff(2)

                pointSets.Add(__pt)
            Next

            Dim caculatedCoeff As Vector(Of Double) = data2DFitting(pointSets, fitting2DMethodsEnum.PARABOLIC)

            Assert.IsTrue((caculatedCoeff - answerCoeff).L2Norm < 0.0000001,
                          (caculatedCoeff - answerCoeff).L2Norm)

            'since it is increasing
            Dim peakValue As Double = pointSets.Min(Function(__pt As Vector(Of Double)) Math.Abs(__pt(variableDefinition.DEPENDENT)))
            Dim peakPoint As Vector(Of Double) =
                pointSets.Find(Function(___every As Vector(Of Double)) ___every(variableDefinition.DEPENDENT) = peakValue)

            Trace.WriteLine(parabolicMaximum(caculatedCoeff))
            Trace.WriteLine(peakPoint(variableDefinition.INDEPENDENT))

        End Sub

        <TestMethod()> Public Sub parabolicMaximumTest()
            Assert.Fail()
        End Sub

        <TestMethod()> Public Sub lineFittingTest()

            'line two coefficient
            Dim answerCoeff As Vector(Of Double) = CreateVector.Random(Of Double)(2)
            Dim pointCounts As Integer = 20

            Dim pointSets As List(Of Vector(Of Double)) = New List(Of Vector(Of Double))

            For index = 0 To pointCounts - 1

                Dim __pt As Vector(Of Double) = CreateVector.Dense(Of Double)(2)
                __pt(variableDefinition.INDEPENDENT) = index
                __pt(variableDefinition.DEPENDENT) = index * answerCoeff(0) + answerCoeff(1)

                pointSets.Add(__pt)
            Next


            Dim caculatedCoeff As Vector(Of Double) = CreateVector.Dense(Of Double)(answerCoeff.Count)

            Assert.IsTrue((caculatedCoeff - answerCoeff).L2Norm > 0.001)

            caculatedCoeff = data2DFitting(pointSets, fitting2DMethodsEnum.LINE)

            Assert.IsTrue((caculatedCoeff - answerCoeff).L2Norm < 0.0000001,
                          (caculatedCoeff - answerCoeff).L2Norm)

        End Sub

        <TestMethod()> Public Sub solveRightSingularVectorTest()

            Dim test As Matrix(Of Double) = CreateMatrix.Random(Of Double)(10, 10)

            Dim __v As Vector(Of Double) = solveRightSingularVector(test)

            Assert.Fail()
        End Sub

        <TestMethod()> Public Sub normalVectorFitTest()

            'ax+by+cz+d=0
            'z = (-d-ax-by)/c

            Dim cloud As List(Of Vector(Of Double)) = New List(Of Vector(Of Double))

            Dim answerCoeff As Vector(Of Double) = CreateVector.Random(Of Double)(4)

            For index = 0 To 100
                'randomize data points
                Dim __point As Vector(Of Double) = CreateVector.Random(Of Double)(3)
                __point(2) = (-answerCoeff(coeffsDefinition.D) - answerCoeff(coeffsDefinition.A) * __point(0) - answerCoeff(coeffsDefinition.B) * __point(1)) / answerCoeff(coeffsDefinition.C)
                cloud.Add(__point)

            Next

            Dim answer As Vector(Of Double) = answerCoeff.Normalize(2)
            Dim calculated As Vector(Of Double) = data3DFitting(cloud)

            Trace.WriteLine(answer.ToVectorString.Replace(vbCrLf, vbTab))
            Trace.WriteLine(calculated.ToVectorString.Replace(vbCrLf, vbTab))

            Assert.Fail()
        End Sub

        <TestMethod()> Public Sub cloudCenterTest()

            Dim nominalCenter As PositionVector = New PositionVector(CreateVector.Random(Of Double)(3),
                                                               Nothing)
            Dim nomialPosition As PositionVector = New PositionVector(Nothing)

            Dim cloud As List(Of Vector(Of Double)) = New List(Of Vector(Of Double))



            Dim radius As Double = 100
            Dim divides As Integer = 20
            Dim radianIncrement As Double = ((360 / divides) / 180) * Math.PI
            Dim radianAccumulation As Double = 0

            For index = 0 To divides - 1
                nomialPosition = nominalCenter.Clone
                With nomialPosition
                    .X = .X + radius * Math.Cos(radianAccumulation)
                    .Y = .Y + radius * Math.Sin(radianAccumulation)
                    .Z = .Z + radius * Math.Sin(radianAccumulation)
                End With
                cloud.Add(nomialPosition.RawValue)
                radianAccumulation += radianIncrement
            Next

            Assert.IsTrue((cloudCenter(cloud) - nominalCenter.RawValue.SubVector(0, 3)).L2Norm < 0.0001,
                          String.Format("Calculated:{0},Nominal:{1}",
                                        cloudCenter(cloud).ToVectorString.Replace(vbCrLf, vbTab),
                                        nominalCenter.RawValue.ToVectorString.Replace(vbCrLf, vbTab)))
        End Sub

        <TestMethod()> Public Sub coordinateFindTest()

            Dim answerTransformation As htmEdgeElementary = New htmEdgeElementary(Nothing, Nothing)
            Dim __angles As Vector(Of Double) = CreateVector.Random(Of Double)(3)
            Dim __positions As Vector(Of Double) = CreateVector.Random(Of Double)(3)

            With answerTransformation
                .RotationMatrix = utilities.RotateTransformation(__angles(0),
                                                                 __angles(1),
                                                                 __angles(2))
                .PositionVector = CreateVector.Dense(Of Double)({__positions(0),
                                                                 __positions(1),
                                                                 __positions(2),
                                                                 1})
            End With

            'randomize point cloud
            Dim cloud As List(Of Vector(Of Double)) = New List(Of Vector(Of Double))
            For index = 0 To 100
                'since cloud should form as a plane , so there is no z value
                cloud.Add((answerTransformation * New PositionVector(CreateVector.Random(Of Double)(2), Nothing)).RawValue)
            Next


            Dim calculatedTransformation As Matrix(Of Double) = coordinateFind(cloud)


            Trace.WriteLine(answerTransformation.RawValue.ToMatrixString)
            Trace.WriteLine(calculatedTransformation.ToMatrixString)

            'condition:
            '1. the calculated z-axis should parallel to answer
            '2. the calculated x-axis/y-axis is perpendicular to calculated z-axis

            Dim dotProductValueZ As Double = calculatedTransformation.Column(2).DotProduct(answerTransformation.FrameVector(frameVectorEnum.VZ))
            Dim dotProductValueX As Double = calculatedTransformation.Column(2).DotProduct(calculatedTransformation.Column(0))
            Dim dotProductValueY As Double = calculatedTransformation.Column(2).DotProduct(calculatedTransformation.Column(1))


            Assert.IsTrue(Math.Abs(dotProductValueZ) = 1,
                          dotProductValueZ)
            Assert.IsTrue(dotProductValueX,
                          dotProductValueX)
            Assert.IsTrue(dotProductValueY,
                          dotProductValueY)

        End Sub

        <TestMethod()> Public Sub line3DIntersectionTest()

            Dim line1 As Vector(Of Double) = CreateVector.Random(Of Double)(2)
            Dim line2 As Vector(Of Double) = CreateVector.Random(Of Double)(2)
            'make sure they are not parallel
            Assert.IsTrue(line1.DotProduct(line2) <> 0)

            'T_local_reference
            Dim givenTransformation As htmEdgeElementary = New htmEdgeElementary(Nothing, Nothing)
            Dim __angles As Vector(Of Double) = CreateVector.Random(Of Double)(3)
            Dim __positions As Vector(Of Double) = CreateVector.Random(Of Double)(3)

            With givenTransformation
                .RotationMatrix = utilities.RotateTransformation(__angles(0),
                                                                 __angles(1),
                                                                 __angles(2))
                .PositionVector = CreateVector.Dense(Of Double)({__positions(0),
                                                                 __positions(1),
                                                                 __positions(2),
                                                                 1})
            End With
            Dim answerintersection3D As Vector(Of Double) = (givenTransformation * New PositionVector(line2DIntersection(line1, line2), Nothing)).RawValue

            '-----------------------------
            '   Test Data generating
            '-----------------------------
            Dim line1Cloud3D As List(Of Vector(Of Double)) = New List(Of Vector(Of Double))
            Dim line2Cloud3D As List(Of Vector(Of Double)) = New List(Of Vector(Of Double))

            Dim __pt2D As Vector(Of Double) = CreateVector.Random(Of Double)(2)

            'generate randomize cloud
            ' y= ax + b
            For index = 1 To 100
                __pt2D = CreateVector.Random(Of Double)(2)
                __pt2D(1) = line1(coeffsDefinition.A) * __pt2D(0) + line1(coeffsDefinition.B)
                line1Cloud3D.Add((givenTransformation * New PositionVector(__pt2D, Nothing)).RawValue)



                __pt2D = CreateVector.Random(Of Double)(2)
                __pt2D(1) = line2(coeffsDefinition.A) * __pt2D(0) + line2(coeffsDefinition.B)
                line2Cloud3D.Add((givenTransformation * New PositionVector(__pt2D, Nothing)).RawValue)
            Next

            Dim calculatedIntersection3D As Vector(Of Double) = line3DIntersection(line1Cloud3D, line2Cloud3D)

            Trace.WriteLine(answerintersection3D.ToVectorString)
            Trace.WriteLine(calculatedIntersection3D.ToVectorString)


            Assert.Fail()
        End Sub

        <TestMethod()> Public Sub line2DIntersectionTest()

            Dim line1 As Vector(Of Double) = CreateVector.Random(Of Double)(2)
            Dim line2 As Vector(Of Double) = CreateVector.Random(Of Double)(2)

            'make sure they are not parallel
            Assert.IsTrue(line1.DotProduct(line2) <> 0)

            Trace.WriteLine(line2DIntersection(line1, line2).ToVectorString)


        End Sub

        <TestMethod()>
        Public Sub paraBolicPlace()

            Dim xRange As Single = 50
            Dim yRange As Single = 50
            Dim xStep As Single = 1
            Dim yStep As Single = 1

            Dim xIncrement As Single = 0
            Dim yIncrement As Single = 0

            Dim dataCloud As List(Of Vector(Of Double)) = New List(Of Vector(Of Double))
            Dim answerCoeff As Vector(Of Double) = CreateVector.Random(Of Double)(6)
            answerCoeff = answerCoeff.Normalize(2)

            While yIncrement <= yRange
                While xIncrement <= xRange
                    dataCloud.Add(CreateVector.Dense(Of Double)({xIncrement,
                                                                yIncrement,
                                                                data3D(xIncrement,
                                                                       yIncrement,
                                                                       answerCoeff, fitting3DMethodsEnum.DOUBLE_PARABOLA)}) +
                                                           CreateVector.Random(Of Double)(3).Normalize(2))
                    xIncrement += xStep
                End While
                xIncrement = 0
                yIncrement += yStep
            End While

            Dim calculatedCoeff As Vector(Of Double) = data3DFitting(dataCloud, fitting3DMethodsEnum.DOUBLE_PARABOLA)


            Assert.IsTrue((answerCoeff - calculatedCoeff).L2Norm < 0.00001,
                          String.Format("{0}{1}{2}",
                                        answerCoeff.ToVectorString.Replace(vbCrLf, vbTab),
                                        vbCrLf,
                                        calculatedCoeff.ToVectorString.Replace(vbCrLf, vbTab)))

        End Sub

    End Class


End Namespace



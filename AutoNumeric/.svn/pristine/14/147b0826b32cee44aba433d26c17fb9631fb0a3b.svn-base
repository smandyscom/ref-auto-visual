Imports MathNet.Numerics.LinearAlgebra
Imports System.Text
Imports AutoNumeric.utilities

Public Class measuredDataPair

    Enum cascadeDefinitionsEnum As Byte
        ERROR_GAIN = 0
        ERROR_POSITION
    End Enum

    ''' <summary>
    ''' 3x1
    ''' </summary>
    ''' <value></value>
    ''' <returns></returns>
    ''' <remarks></remarks>
    ReadOnly Property OriginalErrorPosition As Vector(Of Double)
        Get
            Return __originalErrorPosition
        End Get
    End Property
    ''' <summary>
    ''' 3x6
    ''' </summary>
    ''' <value></value>
    ''' <returns></returns>
    ''' <remarks></remarks>
    ReadOnly Property ErrorGain As Matrix(Of Double)
        Get
            Return __errorGain
        End Get
    End Property
    ReadOnly Property OriginalIdealPosition As Vector(Of Double)
        Get
            Return __originalIdealPosition
        End Get
    End Property
    ReadOnly Property OriginalRealPosition As Vector(Of Double)
        Get
            Return __originalRealPosition
        End Get
    End Property
    ReadOnly Property ErrorLength As Double
        Get
            Return __dimensionErrorPosition.L2Norm
        End Get
    End Property

    Friend __errorGain As Matrix(Of Double) = Nothing
    ''' <summary>
    ''' Definition : ideal-real
    ''' </summary>
    ''' <remarks></remarks>
    Friend __originalErrorPosition As Vector(Of Double) = Nothing

    Friend __originalIdealPosition As Vector(Of Double) = Nothing
    Friend __originalRealPosition As Vector(Of Double) = Nothing

    Friend __dimensionIdealPosition As Vector(Of Double) = Nothing
    Friend __dimensionRealPosition As Vector(Of Double) = Nothing
    Friend __dimensionErrorPosition As Vector(Of Double) = Nothing
    Friend __gainSelection As Integer = 0
    ''' <summary>
    ''' Turns data pair into ErrorGain Collection and ErrorValue Collection
    ''' </summary>
    ''' <param name="collection"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Friend Shared Function pairsCascade(collection As List(Of measuredDataPair)) As Object

        Dim cascadedErrorPosition As Matrix(Of Double) = Nothing
        Dim cascadedErrorGain As Matrix(Of Double) = Nothing

        For index = 0 To collection.Count - 1
            'according dimension count to seperate sub matrix
            'e.g takes the X/Y parts only , discard Z part
            Dim __gain = collection(index).__errorGain
            If cascadedErrorGain Is Nothing Then
                'for the first one
                cascadedErrorGain = __gain
            Else
                cascadedErrorGain = cascadedErrorGain.Stack(__gain)
            End If

            Dim __vector = collection(index).__dimensionErrorPosition
            If cascadedErrorPosition Is Nothing Then
                'for the first one
                cascadedErrorPosition = __vector.ToColumnMatrix
            Else
                cascadedErrorPosition = cascadedErrorPosition.Stack(__vector.ToColumnMatrix)
            End If
        Next

        Return {cascadedErrorGain,
                CreateVector.Dense(Of Double)(cascadedErrorPosition.ToColumnMajorArray)}
    End Function
    ''' <summary>
    ''' Turns data pair into fitted error vector
    ''' </summary>
    ''' <param name="collection"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Shared Function fitErrorVector(collection As List(Of measuredDataPair)) As Vector(Of Double)
        'cascade datas
        Dim cascade = measuredDataPair.pairsCascade(collection)
        Dim errorGains As Matrix(Of Double) = CType(cascade(cascadeDefinitionsEnum.ERROR_GAIN), Matrix(Of Double))
        Dim errorPositions As Vector(Of Double) = CType(cascade(cascadeDefinitionsEnum.ERROR_POSITION), Vector(Of Double))

        'errorGain may not full rank (neither column nor row)
        'do pseudoinverse to analyze the error vector
        Return errorGains.PseudoInverse * errorPositions
    End Function


    Shared iterationTolerance As Double = 0.000001
    Shared iterationGoal As Integer = 100
    Shared iterationCounter As Integer = 0
    Shared lastNorm As Double = Double.MaxValue
    ''' <summary>
    ''' 
    ''' </summary>
    ''' <param name="collection"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Shared Function fitTransformation(collection As List(Of measuredDataPair)) As htmEdgeElementary
        iterationCounter = 0
        Dim output As eulerHtmTR = New eulerHtmTR(Nothing,
                                                                Nothing)
        Dim __revisedCollection As List(Of measuredDataPair) = New List(Of measuredDataPair)(collection)
        '-----------------------------
        'use full xyz rotate/translate
        '-----------------------------
        Dim errorMatrix As eulerHtmTR = New eulerHtmTR(Nothing,
                                               Nothing)

        lastNorm = Double.MaxValue 'reset
        While True

            __revisedCollection.Clear()
            For Each item As measuredDataPair In collection
                __revisedCollection.Add(New measuredDataPair((output * New PositionVector(item.OriginalIdealPosition, Nothing)).RawValue,
                                                             item.OriginalRealPosition,
                                                              item.__gainSelection))
            Next
            errorMatrix.ControlVector = fitErrorVector(__revisedCollection)


            If errorMatrix.ControlVector.L2Norm > lastNorm Or
                iterationCounter = iterationGoal Then
                'iteration end
                Exit While
            Else
                'compensation
                output.RawValue = errorMatrix.RawValue * output.RawValue
            End If

            lastNorm = errorMatrix.ControlVector.L2Norm
            iterationCounter += 1

        End While


        'Do
        '    If iterationCounter = 0 Then
        '        'first time , reset
        '        lastNorm = Double.MaxValue
        '    Else
        '        'reentry
        '        lastNorm = errorMatrix.ControlVector.L2Norm
        '    End If

        '    errorMatrix.ControlVector = fitErrorVector(__revisedCollection)

        '    'cascade errors
        '    output = errorMatrix * output

        '    __revisedCollection.Clear()
        '    For Each item As measuredDataPair In collection
        '        __revisedCollection.Add(New measuredDataPair((output * New PositionVector(item.OriginalIdealPosition, Nothing)).RawValue,
        '                                                     item.OriginalRealPosition,
        '                                                      item.__gainSelection))
        '    Next

        '    iterationCounter += 1
        '    'until error vector less than...

        'Loop Until errorMatrix.ControlVector.L2Norm > lastNorm Or
        '    iterationCounter = iterationGoal

        Return output

    End Function


    Shared Function pairsOutput(collection As List(Of measuredDataPair)) As String
        Dim sb As StringBuilder = New StringBuilder
        sb.AppendLine("Real,Ideal,Error")
        collection.ForEach(Sub(pair As measuredDataPair)
                               With sb
                                   'real ideal error
                                   .AppendLine(String.Format("{0},{1},{2}",
                                                             pair.__dimensionRealPosition.ToVectorString.Replace(vbCrLf, vbTab),
                                                             pair.OriginalIdealPosition.ToVectorString.Replace(vbCrLf, vbTab),
                                                             pair.__dimensionErrorPosition.ToVectorString.Replace(vbCrLf, vbTab)))
                               End With
                           End Sub)

        Return sb.ToString
    End Function

    ''' <summary>
    ''' Ideal : the value calculated throught the known chain
    ''' Real : the value measured in unknown chain
    ''' </summary>
    ''' <param name="originalIdealPosition"></param>
    ''' <param name="originalRealPosition"></param>
    ''' <param name="selection"></param>
    ''' <remarks></remarks>
    Sub New(originalIdealPosition As Vector(Of Double),
            originalRealPosition As Vector(Of Double),
           Optional selection As utilities.selectionEnums = selectionEnums.X Or
           selectionEnums.Y Or
           selectionEnums.Z)

        Dim value = [Enum].GetValues(GetType(utilities.selectionEnums))

        Dim idealValues As List(Of Double) = New List(Of Double)
        Dim realValues As List(Of Double) = New List(Of Double)

        For index = 0 To value.Length - 1
            If selection And value(index) Then
                'if dimension selected
                idealValues.Add(originalIdealPosition(index))
                realValues.Add(originalRealPosition(index))
            End If
        Next

        Me.__originalIdealPosition = originalIdealPosition
        Me.__originalRealPosition = originalRealPosition
        Me.__originalErrorPosition = Me.__originalIdealPosition - Me.__originalRealPosition

        Me.__gainSelection = selection
        Me.__dimensionIdealPosition = CreateVector.DenseOfArray(Of Double)(idealValues.ToArray)
        Me.__dimensionRealPosition = CreateVector.DenseOfArray(Of Double)(realValues.ToArray)
        Me.__dimensionErrorPosition = __dimensionIdealPosition - __dimensionRealPosition
        Me.__errorGain = utilities.position2ErrorGain(originalIdealPosition,
                                                      selection)
    End Sub

    ''' <summary>
    ''' 
    ''' </summary>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Shared Function averageErrorVector(collection As List(Of measuredDataPair)) As Vector(Of Double)

        Dim __sum As Vector(Of Double) = CreateVector.Dense(Of Double)(collection.First.OriginalErrorPosition.Count)

        collection.ForEach(Sub(__data As measuredDataPair) __sum += __data.OriginalErrorPosition)

        Return __sum / collection.Count
    End Function
    ''' <summary>
    ''' 
    ''' </summary>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Shared Function averageErrorLength(collection As List(Of measuredDataPair)) As Double

        Dim __sum As Double = 0

        collection.ForEach(Sub(__data As measuredDataPair) __sum += __data.ErrorLength)

        Return __sum / collection.Count
    End Function
    ''' <summary>
    ''' 
    ''' </summary>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Shared Function deviationErrorLength(collection As List(Of measuredDataPair)) As Double

        Dim __sample As List(Of Double) = New List(Of Double)

        collection.ForEach(Sub(__data As measuredDataPair) __sample.Add(__data.ErrorLength))

        Return MathNet.Numerics.Statistics.Statistics.StandardDeviation(__sample)
    End Function
End Class
Imports MathNet.Numerics.LinearAlgebra

Public Class measuredDataPair

    Enum cascadeDefinitionsEnum As Byte
        ERROR_GAIN = 0
        ERROR_POSITION
    End Enum

    ''' <summary>
    ''' 3x1
    ''' </summary>
    ''' <value></value>
    ''' <returns></returns>
    ''' <remarks></remarks>
    ReadOnly Property ErrorPosition As Vector(Of Double)
        Get
            Return __errorPosition
        End Get
    End Property
    ''' <summary>
    ''' 3x6
    ''' </summary>
    ''' <value></value>
    ''' <returns></returns>
    ''' <remarks></remarks>
    ReadOnly Property ErrorGain As Matrix(Of Double)
        Get
            Return __errorGain
        End Get
    End Property

    Friend __errorGain As Matrix(Of Double) = Nothing
    ''' <summary>
    ''' Definition : ideal-real
    ''' </summary>
    ''' <remarks></remarks>
    Friend __errorPosition As Vector(Of Double) = Nothing


    ''' <summary>
    ''' Turns data pair into ErrorGain Collection and ErrorValue Collection
    ''' </summary>
    ''' <param name="collection"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Friend Shared Function pairsCascade(collection As List(Of measuredDataPair)) As Object

        Dim cascadedErrorPosition As Matrix(Of Double) = Nothing
        Dim cascadedErrorGain As Matrix(Of Double) = Nothing

        For index = 0 To collection.Count - 1
            'according dimension count to seperate sub matrix
            'e.g takes the X/Y parts only , discard Z part
            Dim __gain = collection(index).__errorGain
            If cascadedErrorGain Is Nothing Then
                'for the first one
                cascadedErrorGain = __gain
            Else
                cascadedErrorGain = cascadedErrorGain.Stack(__gain)
            End If

            Dim __vector = collection(index).__errorPosition
            If cascadedErrorPosition Is Nothing Then
                'for the first one
                cascadedErrorPosition = __vector.ToColumnMatrix
            Else
                cascadedErrorPosition = cascadedErrorPosition.Stack(__vector.ToColumnMatrix)
            End If
        Next

        Return {cascadedErrorGain,
                CreateVector.Dense(Of Double)(cascadedErrorPosition.ToColumnMajorArray)}
    End Function
    ''' <summary>
    ''' Turns data pair into fitted error vector
    ''' </summary>
    ''' <param name="collection"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Shared Function fitErrorVector(collection As List(Of measuredDataPair)) As Vector(Of Double)
        'cascade datas
        Dim cascade = measuredDataPair.pairsCascade(collection)
        Dim errorGains As Matrix(Of Double) = CType(cascade(cascadeDefinitionsEnum.ERROR_GAIN), Matrix(Of Double))
        Dim errorPositions As Vector(Of Double) = CType(cascade(cascadeDefinitionsEnum.ERROR_POSITION), Vector(Of Double))
        'do pseudoinverse to analyze the error vector
        Return errorGains.PseudoInverse() * errorPositions
    End Function

    ''' <summary>
    ''' 
    ''' </summary>
    ''' <param name="__errorGain"></param>
    ''' <param name="__errorPosition"></param>
    ''' <remarks></remarks>
    Protected Sub New(__errorGain As Matrix(Of Double),
            __errorPosition As Vector(Of Double))
        Me.__errorGain = __errorGain
        Me.__errorPosition = __errorPosition
    End Sub

    Sub New(nominalPosition As Vector(Of Double),
            realPosition As Vector(Of Double))
        __errorPosition = nominalPosition - realPosition

        If __errorPosition.Count > 3 Then
            __errorPosition = __errorPosition.SubVector(0, 3)
        End If
        If nominalPosition.Count > 3 Then
            nominalPosition = nominalPosition.SubVector(0, 3)
        End If

        __errorGain = AutoNumeric.utilities.position2ErrorGain(nominalPosition)
    End Sub

End Class
Imports MathNet.Numerics.LinearAlgebra
Imports System.Runtime.CompilerServices
Imports System.IO
Imports MathNet.Numerics.Data.Text

''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
Public Class utilities

    ''' <summary>
    '               |  1     0      0     0  |
    ' T_rotateX =   |  0  cos(a) -sin(a)  0  |
    '               |  0  sin(a)  cos(a)  0  |
    '               |  0     0      0     1  |
    '               |  cos(b)  0  sin(b)  0  |
    ' T_rotateY =   |    0     1    0     0  |
    '               | -sin(b)  0  cos(b)  0  |
    '               |    0     0    0     1  |
    '               |  cos(c) -sin(c)  0  0  |
    ' T_rotateZ =   |  sin(c)  cos(c)  0  0  |
    '               |    0       0     1  0  |
    '               |    0       0     0  1  |    
    ''' </summary>
    ''' <param name="theta_x"></param>
    ''' <param name="theta_y"></param>
    ''' <param name="theta_z"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Public Shared Function RotateTransformation(theta_x As Double, theta_y As Double, theta_z As Double) As Matrix(Of Double)
        Dim mat_rotateX As Matrix(Of Double) = Matrix(Of Double).Build.Dense(4, 4, {1, 0, 0, 0, 0, Math.Cos(theta_x), Math.Sin(theta_x), 0, 0, -Math.Sin(theta_x), Math.Cos(theta_x), 0, 0, 0, 0, 1})
        Dim mat_rotateY As Matrix(Of Double) = Matrix(Of Double).Build.Dense(4, 4, {Math.Cos(theta_y), 0, -Math.Sin(theta_y), 0, 0, 1, 0, 0, Math.Sin(theta_y), 0, Math.Cos(theta_y), 0, 0, 0, 0, 1})
        Dim mat_rotateZ As Matrix(Of Double) = Matrix(Of Double).Build.Dense(4, 4, {Math.Cos(theta_z), Math.Sin(theta_z), 0, 0, -Math.Sin(theta_z), Math.Cos(theta_z), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1})

        Return mat_rotateX * mat_rotateY * mat_rotateZ
    End Function

    ''' <summary>
    ''' Error is defined by nominal-real
    ''' Given Nominal Postion , turns into Error Gain Form
    ''' </summary>
    ''' <param name="nominalPostion"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Public Shared Function position2ErrorGain(nominalPostion As PositionVector) As Matrix(Of Double)
        With nominalPostion
            Return CreateMatrix.Dense(Of Double)(3, 6, {0, .Z, .Y, -1, 0, 0,
                                                        -.Z, 0, -.X, 0, -1, 0,
                                                        -.Y, .X, 0, 0, 0, -1})
        End With
    End Function


    Public Shared Function matrix2String(value As Matrix(Of Double)) As String
        Dim sw As StringWriter = New StringWriter()
        DelimitedWriter.Write(Of Double)(sw, value, ",")
        Return sw.ToString
    End Function
    Public Shared Function string2Matrix(value As String) As Matrix(Of Double)
        Dim sr As StringReader = New StringReader(value)
        Return DelimitedReader.Read(Of Double)(sr, False, ",")
    End Function

End Class

'Public Module matrixExtension
'    ''' <summary>
'    ''' Return a pseudo inverse
'    ''' </summary>
'    ''' <param name="matrice"></param>
'    ''' <returns></returns>
'    ''' <remarks></remarks>
'    <Extension()>
'    Public Function PseudoInverse(matrice As Matrix(Of Double)) As Matrix(Of Double)
'        ' Reference: https://github.com/mathnet/mathnet-numerics/issues/432

'        Dim svd As Factorization.Svd(Of Double) = matrice.Svd(True)
'        Dim mat_W As Matrix(Of Double) = svd.W
'        Dim vec_s As Vector(Of Double) = svd.S
'        Dim torlerance As Double = Math.Max(matrice.RowCount, matrice.ColumnCount) * matrice.L2Norm * MathNet.Numerics.Precision.DoublePrecision

'        For Each si In vec_s
'            If si < torlerance Then
'                si = 0
'            Else
'                si = 1 / si
'            End If
'        Next

'        mat_W.SetDiagonal(vec_s)

'        Return (svd.U * mat_W * svd.VT).Transpose()
'    End Function
'End Module
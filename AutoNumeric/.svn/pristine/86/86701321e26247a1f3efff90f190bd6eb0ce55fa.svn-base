Imports Automation
Imports MathNet.Numerics.LinearAlgebra
Imports AutoNumeric.measureProcedureType1Base.dataPair
''' <summary>
''' Offer the basic data procedure flow
''' Output: error matrix updating
''' </summary>
''' <remarks></remarks>
Public Class measureProcedureType1Base
    Inherits systemControlPrototype

    Protected Friend Class dataPair

        Enum cascadeDefinitionsEnum As Byte
            ERROR_GAIN = 0
            ERROR_POSITION
        End Enum


        Friend errorGain As Matrix(Of Double) = Nothing
        Friend errorPosition As Vector(Of Double) = Nothing

        ''' <summary>
        ''' Turns data pair into ErrorGain Collection and ErrorValue Collection
        ''' </summary>
        ''' <param name="collection"></param>
        ''' <param name="dimensionCount">
        ''' Control which dimension should be cascaded
        ''' </param>
        ''' <returns></returns>
        ''' <remarks></remarks>
        Friend Shared Function pairsCascade(collection As List(Of dataPair), Optional dimensionCount As Byte = 0) As Object

            Dim cascadedErrorPosition As Vector(Of Double) = Nothing
            Dim cascadedErrorGain As Matrix(Of Double) = Nothing

            For index = 0 To collection.Count - 1
                'according dimension count to seperate sub matrix
                'e.g takes the X/Y parts only , discard Z part
                Dim __gain = collection(index).errorGain.SubMatrix(0, dimensionCount,
                                                                   0, collection(index).errorGain.ColumnCount)
                If cascadedErrorGain Is Nothing Then
                    'for the first one
                    cascadedErrorGain = __gain
                Else
                    cascadedErrorGain.Stack(__gain)
                End If

                Dim __vector = collection(index).errorPosition.SubVector(0, dimensionCount)
                If cascadedErrorPosition Is Nothing Then
                    'for the first one
                    cascadedErrorPosition = __vector
                Else
                    cascadedErrorPosition.Concat(__vector)
                End If
            Next

            Return {cascadedErrorGain, cascadedErrorPosition}
        End Function

        ''' <summary>
        ''' 
        ''' </summary>
        ''' <param name="__errorGain"></param>
        ''' <param name="__errorPosition"></param>
        ''' <remarks></remarks>
        Sub New(__errorGain As Matrix(Of Double),
                __errorPosition As Vector(Of Double))
            Me.errorGain = __errorGain
            Me.errorPosition = __errorPosition
        End Sub

    End Class

    ReadOnly Property ErrorGain As Matrix(Of Double)
        Get
            Return utilities.position2ErrorGain(idealPosition)
        End Get
    End Property
    ''' <summary>
    ''' Definition : ideal-real
    ''' </summary>
    ''' <value></value>
    ''' <returns></returns>
    ''' <remarks></remarks>
    ReadOnly Property ErrorPosition As Vector(Of Double)
        Get
            Return idealPosition.RawValue - realPosition.RawValue
        End Get
    End Property

    ReadOnly Property CurrentDataIndex As Integer
        Get
            Return dataPairCollection.Count - 1
        End Get
    End Property

    Dim idealPosition As PositionVector = Nothing
    Dim realPosition As PositionVector = Nothing
    ''' <summary>
    ''' Used to store data pair
    ''' </summary>
    ''' <remarks></remarks>
    Dim dataPairCollection As List(Of dataPair) = New List(Of dataPair)
    Dim dataGoal = 10

    Dim correspondingErrorMatrix As errorHtm = Nothing
    Dim lowerThreshold As Double = 0.001

    Dim tryingTimes As Integer = 0
    Dim tryingGoal As Integer = 3

    ''' <summary>
    ''' 
    ''' </summary>
    ''' <param name="state"></param>
    ''' <param name="dataIndex"> pass current running index </param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Delegate Function meausreProcedurePrototype(ByRef state, ByVal dataIndex) As Boolean
    Dim measureProcedureState As Integer = 0
    Dim measureProcedure As meausreProcedurePrototype = Nothing

    Enum dataHandlingState As Integer
        MEASURING
        MEASURED
        DATA_HANDLING
    End Enum


    Function stateMeasure() As Integer

        'through the measure procedure , get the ideal position and real position(measured one)
        'turns into error gain/error form (error  = ideal-real)
        'interating above procedure , until enough data count got
        'processing datas, error vector/error matrix calculated
        'update error matrix
        'check if norm of error vector is smaller than low threshold
        ' if yes , quit procedure
        ' if no  , iterating

        Select Case systemSubState
            Case 0
                If True Then
                    systemSubState = 10
                End If
            Case 10
                'measure procedures
                If measureProcedure.Invoke(measureProcedureState, dataPairCollection.Count) Then
                    measureProcedureState = 0 'reset

                    'measured done ,take data into collection
                    dataPairCollection.Add(New dataPair(Me.ErrorGain, Me.ErrorPosition))

                    If dataPairCollection.Count < dataGoal Then
                        'do next measurement
                    Else
                        'done , do further processing

                        'cascade datas
                        Dim cascade = dataPair.pairsCascade(dataPairCollection)
                        'do pseudoinverse to analyze the error vector
                        Dim errorVector = CType(cascade(cascadeDefinitionsEnum.ERROR_GAIN), Matrix(Of Double)).PseudoInverse() *
                            CType(cascade(cascadeDefinitionsEnum.ERROR_POSITION), Vector(Of Double))
                        'update current error matrix
                        correspondingErrorMatrix.ErrorVector = errorVector

                        If errorVector.L2Norm <= lowerThreshold Then
                            'converged , procedure done

                        ElseIf errorVector.L2Norm > lowerThreshold And
                            tryingTimes < tryingGoal Then

                            dataPairCollection.Clear()
                            tryingTimes += 1
                            'not converged , but trying times not over the given value
                            'keep trying
                        Else
                            'not converged, trying times over the given value
                            'abort
                        End If
                    End If

                Else
                    '--------------------------
                    '   Measuring
                    '--------------------------
                End If
            Case 2

            Case 10

            Case Else

        End Select


        Return 0
    End Function


End Class

Imports MathNet.Numerics.LinearAlgebra
Imports System.Text
Imports AutoNumeric.utilities

Public Class measuredDataPair

    Enum cascadeDefinitionsEnum As Byte
        ERROR_GAIN = 0
        ERROR_POSITION
    End Enum

    ''' <summary>
    ''' 3x1
    ''' </summary>
    ''' <value></value>
    ''' <returns></returns>
    ''' <remarks></remarks>
    ReadOnly Property ErrorPosition As Vector(Of Double)
        Get
            Return __errorPosition
        End Get
    End Property
    ''' <summary>
    ''' 3x6
    ''' </summary>
    ''' <value></value>
    ''' <returns></returns>
    ''' <remarks></remarks>
    ReadOnly Property ErrorGain As Matrix(Of Double)
        Get
            Return __errorGain
        End Get
    End Property

    Friend __errorGain As Matrix(Of Double) = Nothing
    ''' <summary>
    ''' Definition : ideal-real
    ''' </summary>
    ''' <remarks></remarks>
    Friend __errorPosition As Vector(Of Double) = Nothing

    Friend __nominalPosition As Vector(Of Double) = Nothing
    Friend __realPosition As Vector(Of Double) = Nothing

    ''' <summary>
    ''' Turns data pair into ErrorGain Collection and ErrorValue Collection
    ''' </summary>
    ''' <param name="collection"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Friend Shared Function pairsCascade(collection As List(Of measuredDataPair)) As Object

        Dim cascadedErrorPosition As Matrix(Of Double) = Nothing
        Dim cascadedErrorGain As Matrix(Of Double) = Nothing

        For index = 0 To collection.Count - 1
            'according dimension count to seperate sub matrix
            'e.g takes the X/Y parts only , discard Z part
            Dim __gain = collection(index).__errorGain
            If cascadedErrorGain Is Nothing Then
                'for the first one
                cascadedErrorGain = __gain
            Else
                cascadedErrorGain = cascadedErrorGain.Stack(__gain)
            End If

            Dim __vector = collection(index).__errorPosition
            If cascadedErrorPosition Is Nothing Then
                'for the first one
                cascadedErrorPosition = __vector.ToColumnMatrix
            Else
                cascadedErrorPosition = cascadedErrorPosition.Stack(__vector.ToColumnMatrix)
            End If
        Next

        Return {cascadedErrorGain,
                CreateVector.Dense(Of Double)(cascadedErrorPosition.ToColumnMajorArray)}
    End Function
    ''' <summary>
    ''' Turns data pair into fitted error vector
    ''' </summary>
    ''' <param name="collection"></param>
    ''' <returns></returns>
    ''' <remarks></remarks>
    Shared Function fitErrorVector(collection As List(Of measuredDataPair)) As Vector(Of Double)
        'cascade datas
        Dim cascade = measuredDataPair.pairsCascade(collection)
        Dim errorGains As Matrix(Of Double) = CType(cascade(cascadeDefinitionsEnum.ERROR_GAIN), Matrix(Of Double))
        Dim errorPositions As Vector(Of Double) = CType(cascade(cascadeDefinitionsEnum.ERROR_POSITION), Vector(Of Double))
        'do pseudoinverse to analyze the error vector
        'Return errorGains.PseudoInverse() * errorPositions
        Return (errorGains.Transpose * errorGains).Inverse * errorGains.Transpose * errorPositions

    End Function
    Shared Function pairsOutput(collection As List(Of measuredDataPair)) As String
        Dim sb As StringBuilder = New StringBuilder
        collection.ForEach(Sub(pair As measuredDataPair)
                               With sb
                                   .AppendLine(String.Format("Real:{0},Nominal:{1},Error:{2}",
                                                             pair.__realPosition.ToVectorString.Replace(vbCrLf, vbTab),
                                                             pair.__nominalPosition.ToVectorString.Replace(vbCrLf, vbTab),
                                                             pair.__errorPosition.ToVectorString.Replace(vbCrLf, vbTab)))
                               End With
                           End Sub)

        Return sb.ToString
    End Function


    ' ''' <summary>
    ' ''' 
    ' ''' </summary>
    ' ''' <param name="__errorGain"></param>
    ' ''' <param name="__errorPosition"></param>
    ' ''' <remarks></remarks>
    'Protected Sub New(__errorGain As Matrix(Of Double),
    '        __errorPosition As Vector(Of Double))
    '    Me.__errorGain = __errorGain
    '    Me.__errorPosition = __errorPosition
    'End Sub

    'Sub New(nominalPosition As Vector(Of Double),
    '        realPosition As Vector(Of Double))

    '    Me.__nominalPosition = nominalPosition
    '    Me.__realPosition = realPosition

    '    __errorPosition = nominalPosition - realPosition

    '    If __errorPosition.Count > 3 Then
    '        __errorPosition = __errorPosition.SubVector(0, 3)
    '    End If
    '    If nominalPosition.Count > 3 Then
    '        nominalPosition = nominalPosition.SubVector(0, 3)
    '    End If

    '    __errorGain = AutoNumeric.utilities.position2ErrorGain(nominalPosition)
    'End Sub

    Sub New(originalNominalPosition As Vector(Of Double),
            originalRealPosition As Vector(Of Double),
            selection As utilities.selectionEnums,
            Optional __option As optionEnums = optionEnums.GEOMETRIC)

        Dim value = [Enum].GetValues(GetType(utilities.selectionEnums))

        Dim nominalValues As List(Of Double) = New List(Of Double)
        Dim realValues As List(Of Double) = New List(Of Double)

        For index = 0 To value.Length - 1
            If selection And value(index) Then
                'if dimension selected
                nominalValues.Add(originalNominalPosition(index))
                realValues.Add(originalRealPosition(index))
            End If
        Next

        Me.__nominalPosition = CreateVector.DenseOfArray(Of Double)(nominalValues.ToArray)
        Me.__realPosition = CreateVector.DenseOfArray(Of Double)(realValues.ToArray)
        Me.__errorPosition = Me.__nominalPosition - Me.__realPosition

        Me.__errorGain = utilities.position2ErrorGain(originalNominalPosition,
                                                      selection,
                                                      __option)
    End Sub

End Class